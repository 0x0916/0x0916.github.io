<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>007-过程调用 - Notes about linux and my work</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="laoqinren" />
  <meta name="description" content="前面文章中介绍了如何控制屏幕光标，如何从硬盘读取数据。这种常用的功能，我们希望将其封装成过程调用，类似于高级语言中的函数，这样当我们需要控制光标或者从硬盘读数据时，就不用写大段的重复代码了。
" />

  <meta name="keywords" content="Linux, kernel" />






<meta name="generator" content="Hugo 0.80.0" />


<link rel="canonical" href="http://linux.laoqinren.net/posts/007-function-call/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="007-过程调用" />
<meta property="og:description" content="前面文章中介绍了如何控制屏幕光标，如何从硬盘读取数据。这种常用的功能，我们希望将其封装成过程调用，类似于高级语言中的函数，这样当我们需要控制光标或者从硬盘读数据时，就不用写大段的重复代码了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://linux.laoqinren.net/posts/007-function-call/" />
<meta property="article:published_time" content="2021-02-26T01:57:49+08:00" />
<meta property="article:modified_time" content="2021-02-26T01:57:49+08:00" />
<meta itemprop="name" content="007-过程调用">
<meta itemprop="description" content="前面文章中介绍了如何控制屏幕光标，如何从硬盘读取数据。这种常用的功能，我们希望将其封装成过程调用，类似于高级语言中的函数，这样当我们需要控制光标或者从硬盘读数据时，就不用写大段的重复代码了。">
<meta itemprop="datePublished" content="2021-02-26T01:57:49+08:00" />
<meta itemprop="dateModified" content="2021-02-26T01:57:49+08:00" />
<meta itemprop="wordCount" content="5615">



<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="007-过程调用"/>
<meta name="twitter:description" content="前面文章中介绍了如何控制屏幕光标，如何从硬盘读取数据。这种常用的功能，我们希望将其封装成过程调用，类似于高级语言中的函数，这样当我们需要控制光标或者从硬盘读数据时，就不用写大段的重复代码了。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Notes</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/linux/">
        <li class="mobile-menu-item">linux</li>
      </a><a href="/kernel/">
        <li class="mobile-menu-item">Kernel</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Blog</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Notes</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/linux/">linux</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/kernel/">Kernel</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Blog</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/archives/">Archives</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">007-过程调用</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-02-26 </span>
        
        <span class="more-meta"> 5615 words </span>
        <span class="more-meta"> 12 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#call-ret-示例">call-ret 示例</a>
      <ul>
        <li><a href="#编译反编译">编译、反编译</a></li>
        <li><a href="#调试">调试</a></li>
      </ul>
    </li>
    <li><a href="#lcall-lret-示例">lcall-lret 示例</a>
      <ul>
        <li><a href="#编译">编译</a></li>
        <li><a href="#调试-1">调试</a></li>
      </ul>
    </li>
    <li><a href="#参数传递">参数传递</a>
      <ul>
        <li><a href="#参数传递示例1">参数传递示例1</a></li>
        <li><a href="#参数传递示例2">参数传递示例2</a></li>
        <li><a href="#参数传递示例3">参数传递示例3</a></li>
      </ul>
    </li>
    <li><a href="#参考文章">参考文章</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>前面文章中介绍了如何控制屏幕光标，如何从硬盘读取数据。这种常用的功能，我们希望将其封装成过程调用，类似于高级语言中的函数，这样当我们需要控制光标或者从硬盘读数据时，就不用写大段的重复代码了。</p>
<p>在<code>CPU</code>中，执行的指令通过<code>cs:ip</code>来确定。过程调用实际上就是通过<code>call</code>或<code>lcall</code>指令来修改<code>ip</code>或<code>cs:ip</code>来达到跳转到另一段指令中执行的目的。</p>
<p><code>call</code>指令通过修改<code>ip</code>来实现过程调用，因为只修改<code>ip</code>，所以被调例程与原例程在同一个代码段内，也称为近调用。处理器在执行<code>call</code>指令时先将<code>call</code>后面的第一条指令的偏移地址压栈，再通过操作数计算出新的<code>ip</code>替换当前<code>ip</code>。</p>
<p><code>lcall</code>指令通过修改<code>cs:ip</code>来实现过程调用，因为同时修改<code>cs</code>和<code>ip</code>，所以被调例程与原例程不在同一个代码段内，也称为远调用。处理器在执行<code>lcall</code>指令时先将<code>cs、ip</code>依次压栈，再用指令中给出的段地址代替<code>cs</code>原有的内容，用指令中给出的偏移地址代替<code>ip</code>原有的内容。</p>
<p>从子例程返回到原例程使用<code>ret</code>或<code>lret</code>指令。<code>ret</code>指令用栈中的数据修改<code>ip</code>的内容，实现近转移；<code>lret</code>用栈中的数据修改<code>cs:ip</code>，实现远转移。<code>CPU</code>执行<code>ret</code>指令时相当于执行<code>pop ip</code>，执行<code>lret</code>指令时相当于执行<code>pop ip</code>、<code>pop cs</code>。</p>
<p>下面我们通过一些简单的例子来学习一下如何使用这些指令。</p>
<h2 id="call-ret-示例">call-ret 示例</h2>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># 告诉编译器以16位模式编译，因为BIOS在加载并运行我们的代码时是处于16位实地址模式的
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.code16</span>

	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$0x7c00</span>, %sp	<span style="color:#75715e"># 设置堆栈栈顶指针。因为call指令和ret指令的执行依赖于堆栈。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">callw</span>	<span style="color:#66d9ef">put_char_A</span>

	<span style="color:#a6e22e">jmp</span>	.

 
put_char_A:
	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$0xb800</span>, %ax
	<span style="color:#a6e22e">movw</span>	%ax, %es
	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$</span><span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">A</span><span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#ae81ff">0x0a00</span>, %es:<span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">retw</span>				<span style="color:#75715e"># 使用ret指令跳回原来的执行流程。
</span><span style="color:#75715e"></span>
	<span style="color:#75715e"># .org伪指令指示编译器把位置计数器移动到操作数所指定的位置，这里是将位置计数器移动到510处
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.org</span>	<span style="color:#ae81ff">510</span>
	<span style="color:#75715e"># .word伪指令指示编译器在当前位置写入一个字大小的数据
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.word</span>	<span style="color:#ae81ff">0xaa55</span>
</code></pre></div><h3 id="编译反编译">编译、反编译</h3>
<pre><code># as --32 boot.s -o boot.o
# objcopy -O binary -j .text boot.o boot.bin
# objdump -D -b binary -m i386 -Mi8086,suffix boot.bin  &gt; boot.asm
# cat boot.asm 

boot.bin:     file format binary


Disassembly of section .data:

00000000 &lt;.data&gt;:
   0:	bc 00 7c             	movw   $0x7c00,%sp
   3:	e8 02 00             	callw  0x8
   6:	eb fe                	jmp    0x6
   8:	b8 00 b8             	movw   $0xb800,%ax
   b:	8e c0                	movw   %ax,%es
   d:	26 c7 06 00 00 41 0a 	movw   $0xa41,%es:0x0
  14:	c3                   	retw   
	...
 1fd:	00 55 aa             	addb   %dl,-0x56(%di)
</code></pre><p>第<code>13</code>行编译后的指令是<code>e8 02 00</code>，其中<code>e8</code>是操作码，<code>02 00</code>是操作数，转换成正常顺序即<code>00 02</code>。编译器在计算这个操作数的时候先使用标号的汇编地址<code>（该例中为8）</code>减去本指令的汇编地址<code>（该例中为3）</code>，再减去<code>3</code>，作为机器指令的操作数。即<code>8 - 3 - 3 = 2</code>。同样，指令在执行时，<code>CPU</code>先用<code>ip</code>当前的值加上指令中的操作数，再加上<code>3</code>，得到偏移地址。然后将<code>call</code>指令之后的第一条指令的地址压入栈中，再使用刚才计算得到的<code>ip</code>替换当前<code>ip</code>，从而完成跳转。因为此时栈中压入的是<code>call</code>后的第一条指令的偏移地址，所以当子例程通过<code>ret</code>返回时，会使用这个地址替换<code>ip</code>。从而使调用例程继续执行后续指令。</p>
<h3 id="调试">调试</h3>
<p>启动虚拟机：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ qemu-system-i386 boota.bin -S -s
</code></pre></div><p>在另一个终端启动<code>gdb</code>,(配合前面提到的<code>.gdbinit</code>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># gdb -q</span>
0x0000fff0 in ?? <span style="color:#f92672">()</span>
warning: A handler <span style="color:#66d9ef">for</span> the OS ABI <span style="color:#e6db74">&#34;GNU/Linux&#34;</span> is not built into this configuration
of GDB.  Attempting to <span style="color:#66d9ef">continue</span> with the default i8086 settings.

The target architecture is assumed to be i8086
Breakpoint <span style="color:#ae81ff">1</span> at 0x7c00

Breakpoint 1, 0x00007c00 in ?? <span style="color:#f92672">()</span>
1: x/i $cs*16+$pc
<span style="color:#f92672">=</span>&gt; 0x7c00:	mov    $0x7c00,%sp
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span>
</code></pre></div><p>向后执行一条指令：</p>
<pre><code>(gdb) si
0x00007c03 in ?? ()
1: x/i $cs*16+$pc
=&gt; 0x7c03:	call   0x7c08
(gdb) 
</code></pre><p>可以看到这里计算出来的地址是<code>0x7c08</code>，当前指令的地址<code>0x7c03</code>，加操作数<code>2</code>，再加<code>3</code>，得到<code>0x7c08</code>。继续执行并查看寄存器内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> si
0x00007c08 in ?? <span style="color:#f92672">()</span>
1: x/i $cs*16+$pc
<span style="color:#f92672">=</span>&gt; 0x7c08:	mov    $0xb800,%ax
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info registers
eax            0xaa55	<span style="color:#ae81ff">43605</span>
ecx            0x0	<span style="color:#ae81ff">0</span>
edx            0x80	<span style="color:#ae81ff">128</span>
ebx            0x0	<span style="color:#ae81ff">0</span>
esp            0x7bfe	0x7bfe
ebp            0x0	0x0
esi            0x0	<span style="color:#ae81ff">0</span>
edi            0x0	<span style="color:#ae81ff">0</span>
eip            0x7c08	0x7c08
eflags         0x202	<span style="color:#f92672">[</span> IF <span style="color:#f92672">]</span>
cs             0x0	<span style="color:#ae81ff">0</span>
ss             0x0	<span style="color:#ae81ff">0</span>
ds             0x0	<span style="color:#ae81ff">0</span>
es             0x0	<span style="color:#ae81ff">0</span>
fs             0x0	<span style="color:#ae81ff">0</span>
gs             0x0	<span style="color:#ae81ff">0</span>
</code></pre></div><p>此时<code>ip</code>的内容为<code>0x7c08</code>，<code>sp</code>的内容为<code>0x7bfe</code>。<code>sp</code>初始时我们设置成了<code>0x7c00</code>，在执行<code>call</code>指令时处理器会将<code>call</code>后面一条指令的偏移地址压栈，所以<code>sp</code>的值变成了<code>0x7bfe</code>。我们来查看一下栈中的内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/1xh 0x7bfe
0x7bfe:	0x7c06
</code></pre></div><p><code>0x7c06</code>正好是后面<code>jmp</code>指令的偏移地址。稍后<code>ret</code>指令执行时会将这个偏移地址从栈中弹出到<code>ip</code>，来跳回到原来的执行流程。</p>
<p>向后执行<code>3</code>条指令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> si <span style="color:#ae81ff">3</span>
0x00007c14 in ?? <span style="color:#f92672">()</span>
1: x/i $cs*16+$pc
<span style="color:#f92672">=</span>&gt; 0x7c14:      ret
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span>
</code></pre></div><p>此时屏幕左上角会打印出字符<code>'A'</code>，常规操作就不贴图了。观察上面的输出，下一条要执行的便是<code>ret</code>指令，查看一下此时的寄存器内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info registers
eax            0xb800	<span style="color:#ae81ff">47104</span>
ecx            0x0	<span style="color:#ae81ff">0</span>
edx            0x80	<span style="color:#ae81ff">128</span>
ebx            0x0	<span style="color:#ae81ff">0</span>
esp            0x7bfe	0x7bfe
ebp            0x0	0x0
esi            0x0	<span style="color:#ae81ff">0</span>
edi            0x0	<span style="color:#ae81ff">0</span>
eip            0x7c14	0x7c14
eflags         0x202	<span style="color:#f92672">[</span> IF <span style="color:#f92672">]</span>
cs             0x0	<span style="color:#ae81ff">0</span>
ss             0x0	<span style="color:#ae81ff">0</span>
ds             0x0	<span style="color:#ae81ff">0</span>
es             0xb800	<span style="color:#ae81ff">47104</span>
fs             0x0	<span style="color:#ae81ff">0</span>
gs             0x0	<span style="color:#ae81ff">0</span>
</code></pre></div><p><code>ip</code>是<code>0x7c14</code>，要跳转到的偏移地址还保存在<code>0x7bfe</code>处。执行<code>ret</code>指令，观察结果：</p>
<pre><code>(gdb) si
0x00007c06 in ?? ()
1: x/i $cs*16+$pc
=&gt; 0x7c06:	jmp    0x7c06
(gdb) info registers
eax            0xb800	47104
ecx            0x0	0
edx            0x80	128
ebx            0x0	0
esp            0x7c00	0x7c00
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x7c06	0x7c06
eflags         0x202	[ IF ]
cs             0x0	0
ss             0x0	0
ds             0x0	0
es             0xb800	47104
fs             0x0	0
gs             0x0	0
</code></pre><p>看到了吗？<code>ip</code>的值已经是<code>0x7c06</code>了，下一条要执行的指令也如我们所愿是<code>jmp</code>了。</p>
<p><code>call</code>指令的操作数还可以在寄存器或内存中，例如<code>callw *%cx</code>或<code>callw *procedure_address</code>。需要注意的是正如你看到的，寄存器或内存地址前需要加一个<code>*</code>，就好像指针一样。具体代码如下：</p>
<pre><code>.code16

movw $0x7c00, %sp

movw $0x7c00 + put_char_A, %cx

callw *%cx

jmp .

put_char_A:
  movw $0xb800, %ax
  movw %ax, %es
  movw $'A' | 0x0a00, %es:0
  retw

.org 510
.word 0xAA55
</code></pre><h2 id="lcall-lret-示例">lcall-lret 示例</h2>
<p>下面来看一个<code>lcall</code>的例子。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># 告诉编译器以16位模式编译，因为BIOS在加载并运行我们的代码时是处于16位实地址模式的
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.code16</span>

	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$0x7c00</span>, %sp	<span style="color:#75715e"># 设置堆栈栈顶指针。因为call指令和ret指令的执行依赖于堆栈。
</span><span style="color:#75715e"></span>
	<span style="color:#75715e"># lcall指令的格式为lcall $section, $offset。0x07d0是远调用的代码段地址，0是段内偏移。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">lcallw</span>	<span style="color:#66d9ef">$0x07d0</span>, <span style="color:#66d9ef">$0</span>

	<span style="color:#a6e22e">jmp</span>	.

	<span style="color:#a6e22e">.org</span> <span style="color:#ae81ff">0x100</span>	<span style="color:#75715e"># 使用伪指令.org将位置计数器移动到了0x100处
</span><span style="color:#75715e"></span>	<span style="color:#75715e"># 因为主引导记录是被加载到0x7c00处的，所以标号put_char_A在程序执行时的实际物理地址是0x7c00 + 0x100 = 0x7d00，对应段地址0x07d0，段内偏移0。
</span><span style="color:#75715e"></span><span style="color:#66d9ef">put_char_A</span>:
	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$0xb800</span>, %ax
	<span style="color:#a6e22e">movw</span>	%ax, %es
	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$</span><span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">A</span><span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#ae81ff">0x0a00</span>, %es:<span style="color:#ae81ff">0</span>
	<span style="color:#a6e22e">lretw</span>				<span style="color:#75715e">#使用lret指令将栈中保存的段内偏移和段地址依次弹出到ip、cs，恢复原来的执行流程。
</span><span style="color:#75715e"></span>
	<span style="color:#75715e"># .org伪指令指示编译器把位置计数器移动到操作数所指定的位置，这里是将位置计数器移动到510处
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.org</span>	<span style="color:#ae81ff">510</span>
	<span style="color:#75715e"># .word伪指令指示编译器在当前位置写入一个字大小的数据
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.word</span>	<span style="color:#ae81ff">0xaa55</span>
</code></pre></div><h3 id="编译">编译</h3>
<pre><code># as --32 boot.s -o boot.o
# objcopy -O binary -j .text boot.o boot.bin
</code></pre><h3 id="调试-1">调试</h3>
<p>启动虚拟机：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">$ qemu-system-i386 boot.bin -S -s
</code></pre></div><p>在另一个终端启动<code>gdb</code>,(配合前面提到的<code>.gdbinit</code>)</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#75715e"># gdb -q</span>
0x0000fff0 in ?? <span style="color:#f92672">()</span>
warning: A handler <span style="color:#66d9ef">for</span> the OS ABI <span style="color:#e6db74">&#34;GNU/Linux&#34;</span> is not built into this configuration
of GDB.  Attempting to <span style="color:#66d9ef">continue</span> with the default i8086 settings.

The target architecture is assumed to be i8086
Breakpoint <span style="color:#ae81ff">1</span> at 0x7c00

Breakpoint 1, 0x00007c00 in ?? <span style="color:#f92672">()</span>
1: x/i $cs*16+$pc
<span style="color:#f92672">=</span>&gt; 0x7c00:	mov    $0x7c00,%sp
</code></pre></div><p>向后执行两条指令，此时已经进入到了子例程，查看寄存器状态：</p>
<pre><code>(gdb) si 2
0x00000000 in ?? ()
1: x/i $cs*16+$pc
   0x7d00:	mov    $0xb800,%ax
(gdb) info registers
eax            0xaa55	43605
ecx            0x0	0
edx            0x80	128
ebx            0x0	0
esp            0x7bfc	0x7bfc
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x0	0x0
eflags         0x202	[ IF ]
cs             0x7d0	2000
ss             0x0	0
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
</code></pre><p>此时已经跳转到了段<code>0x7d0</code>，段内偏移<code>0x0</code>处了。<code>sp</code>也因为<code>cs:ip</code>压入栈中变成了<code>0x7bfc</code>，查看栈中的内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/2xh 0x7bfc
0x7bfc:	0x7c08	0x0000
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> 
</code></pre></div><p>低地址处是<code>ip 0x7c08</code>，高地址处是<code>cs 0x0000</code>。向后执行<code>4</code>条指令并查看寄存器内容：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> si <span style="color:#ae81ff">4</span>
0x00007c08 in ?? <span style="color:#f92672">()</span>
1: x/i $cs*16+$pc
<span style="color:#f92672">=</span>&gt; 0x7c08:	jmp    0x7c08
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info registers
eax            0xb800	<span style="color:#ae81ff">47104</span>
ecx            0x0	<span style="color:#ae81ff">0</span>
edx            0x80	<span style="color:#ae81ff">128</span>
ebx            0x0	<span style="color:#ae81ff">0</span>
esp            0x7c00	0x7c00
ebp            0x0	0x0
esi            0x0	<span style="color:#ae81ff">0</span>
edi            0x0	<span style="color:#ae81ff">0</span>
eip            0x7c08	0x7c08
eflags         0x202	<span style="color:#f92672">[</span> IF <span style="color:#f92672">]</span>
cs             0x0	<span style="color:#ae81ff">0</span>
ss             0x0	<span style="color:#ae81ff">0</span>
ds             0x0	<span style="color:#ae81ff">0</span>
es             0xb800	<span style="color:#ae81ff">47104</span>
fs             0x0	<span style="color:#ae81ff">0</span>
gs             0x0	<span style="color:#ae81ff">0</span>
</code></pre></div><p>可以看到在<code>lret</code>指令执行后，<code>cs</code>恢复成了<code>0x0</code>，<code>ip</code>恢复成了<code>0x7c08</code>。<code>sp</code>因为<code>ip</code>和<code>cs</code>的出栈恢复了初始值<code>0x7c00</code>。</p>
<p><code>lcall</code>的操作数也可以在内存中，例如<code>lcallw *procedure_address</code>。具体代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">.code16</span>

<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x07c0</span>, %ax
<span style="color:#a6e22e">movw</span> %ax, %ds

<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x7c00</span>, %sp

<span style="color:#a6e22e">lcallw</span> *<span style="color:#66d9ef">procedure_address</span>

<span style="color:#a6e22e">jmp</span> .

<span style="color:#a6e22e">.org</span> <span style="color:#ae81ff">0x100</span>
put_char_A:
  <span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0xb800</span>, %ax
  <span style="color:#a6e22e">movw</span> %ax, %es
  <span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$</span><span style="color:#960050;background-color:#1e0010">&#39;</span><span style="color:#66d9ef">A</span><span style="color:#960050;background-color:#1e0010">&#39;</span> <span style="color:#960050;background-color:#1e0010">|</span> <span style="color:#ae81ff">0x0a00</span>, %es:<span style="color:#ae81ff">0</span>
  <span style="color:#a6e22e">lretw</span>

procedure_address:
  <span style="color:#75715e"># 偏移地址, 段地址
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">.word</span> <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0x07d0</span>

<span style="color:#a6e22e">.org</span> <span style="color:#ae81ff">510</span>
<span style="color:#a6e22e">.word</span> <span style="color:#ae81ff">0xAA55</span>
</code></pre></div><h2 id="参数传递">参数传递</h2>
<p>我们封装过程是为了方便调用，避免写重复的代码。过程调用时通常需要通过传递参数来控制过程的执行，下面我们来讲一讲参数传递时的一些规范和需要注意的地方。</p>
<h3 id="参数传递示例1">参数传递示例1</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># 告诉编译器以16位模式编译，因为BIOS在加载并运行我们的代码时是处于16位实地址模式的
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.code16</span>

	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$0x7c00</span>, %sp	<span style="color:#75715e"># 设置堆栈栈顶指针。因为call指令和ret指令的执行依赖于堆栈。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">callw</span>	<span style="color:#66d9ef">set_cursor</span>

	<span style="color:#a6e22e">jmp</span>	.

<span style="color:#75715e"># 目的: 设置光标位置为 0
</span><span style="color:#75715e">#
</span><span style="color:#75715e"># 输入: 无
</span><span style="color:#75715e">#
</span><span style="color:#75715e"># 输出: 无
</span><span style="color:#75715e"></span>set_cursor:
	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d4</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#66d9ef">$0xe</span>, %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d5</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#66d9ef">$0</span>, %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d4</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#66d9ef">$0xf</span>, %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d5</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#66d9ef">$0</span>, %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">retw</span>


	<span style="color:#75715e"># .org伪指令指示编译器把位置计数器移动到操作数所指定的位置，这里是将位置计数器移动到510处
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.org</span>	<span style="color:#ae81ff">510</span>
	<span style="color:#75715e"># .word伪指令指示编译器在当前位置写入一个字大小的数据
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.word</span>	<span style="color:#ae81ff">0xaa55</span>
</code></pre></div><p>这个例子中的过程<code>set_cursor</code>，或者称为函数，没有输入，也没有输出。这个函数实际上是没有什么实际用处的，因为它只能将光标位置设置为<code>0</code>，即屏幕左上角。想要这个函数有实际的用处的话就需要给它传递参数，将想要设置的位置作为参数传递给它。传递参数的方式大体上来说有三种：</p>
<ol>
<li>通过寄存器传递。即将参数预先放入寄存器中，被调用的函数执行时去这个寄存器中获取参数。</li>
<li>通过堆栈传递。即调用函数前，先将参数压入栈中，被调函数通过<code>bp</code>寄存器间接寻址，获取堆栈上放置的参数。</li>
<li>通过寄存器和堆栈传递。即一部分参数放在寄存器中，一部分放在堆栈上。</li>
</ol>
<p>通过寄存器传递参数很简单，所以我们主要讲解一下通过堆栈传递参数时需要注意的地方。下面看一下改造后的可以接收参数的<code>set_cursor</code>。</p>
<h3 id="参数传递示例2">参数传递示例2</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># 告诉编译器以16位模式编译，因为BIOS在加载并运行我们的代码时是处于16位实地址模式的
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.code16</span>

	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$0x7c00</span>, %sp	<span style="color:#75715e"># 设置堆栈栈顶指针。因为call指令和ret指令的执行依赖于堆栈。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">pushw</span>	<span style="color:#66d9ef">$79</span>		<span style="color:#75715e"># 将参数79压入栈中，因为一行是80列，从0开始计数，79是第一行的最后一列。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">callw</span>	<span style="color:#66d9ef">set_cursor</span>	<span style="color:#75715e"># 调用set_cursor，注意这里有一个隐含的将ip压栈的操作。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">addw</span>	<span style="color:#66d9ef">$2</span>, %sp		<span style="color:#75715e"># 用于恢复栈顶指针。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">jmp</span>	.

<span style="color:#75715e"># 目的: 设置光标位置
</span><span style="color:#75715e">#
</span><span style="color:#75715e"># 输入:
</span><span style="color:#75715e">#   参数1 光标所在位置
</span><span style="color:#75715e">#
</span><span style="color:#75715e"># 输出: 无
</span><span style="color:#75715e"></span>set_cursor:
	<span style="color:#a6e22e">movw</span> %sp, %bp	<span style="color:#75715e"># 将当前栈顶指针复制给bp，因为要通过bp间接访问堆栈中的参数。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d4</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#66d9ef">$0xe</span>, %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#75715e"># 分别通过3(%bp)、2(%bp)访问参数的高8位和低8位。此时bp指向栈顶，从栈顶向上的两个字节保存的是ip，即偏移量为0, 1的两个内存单元，2, 3这两个单元保存的是我们压入栈中的参数。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d5</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#ae81ff">3</span>(%bp), %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d4</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#66d9ef">$0xf</span>, %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d5</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#ae81ff">2</span>(%bp), %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">retw</span>		<span style="color:#75715e"># 通过ret从函数返回，同时将ip出栈，此时堆栈中只剩调用函数之前压入的参数了。
</span><span style="color:#75715e"></span>

	<span style="color:#75715e"># .org伪指令指示编译器把位置计数器移动到操作数所指定的位置，这里是将位置计数器移动到510处
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.org</span>	<span style="color:#ae81ff">510</span>
	<span style="color:#75715e"># .word伪指令指示编译器在当前位置写入一个字大小的数据
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.word</span>	<span style="color:#ae81ff">0xaa55</span>
</code></pre></div><p>编译并调试</p>
<pre><code># as --32 boot.s -o boot.o
# objcopy -O binary -j .text boot.o boot.bin
# qemu-system-i386 boot.bin -S -s
</code></pre><pre><code># gdb -q
0x0000fff0 in ?? ()
warning: A handler for the OS ABI &quot;GNU/Linux&quot; is not built into this configuration
of GDB.  Attempting to continue with the default i8086 settings.

The target architecture is assumed to be i8086
Breakpoint 1 at 0x7c00

Breakpoint 1, 0x00007c00 in ?? ()
1: x/i $cs*16+$pc
=&gt; 0x7c00:	mov    $0x7c00,%sp
</code></pre><p>设置<code>sp</code>并查看寄存器内容：</p>
<pre><code>(gdb) si
0x00007c03 in ?? ()
1: x/i $cs*16+$pc
=&gt; 0x7c03:	push   $0x4f
(gdb) info registers
eax            0xaa55	43605
ecx            0x0	0
edx            0x80	128
ebx            0x0	0
esp            0x7c00	0x7c00
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x7c03	0x7c03
eflags         0x202	[ IF ]
cs             0x0	0
ss             0x0	0
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
</code></pre><p>此时<code>sp</code>指向<code>0x7c00</code>，将参数压栈并查看寄存器和堆栈内容：</p>
<pre><code>(gdb) si
0x00007c05 in ?? ()
1: x/i $cs*16+$pc
=&gt; 0x7c05:	call   0x7c0d
(gdb) info registers
eax            0xaa55	43605
ecx            0x0	0
edx            0x80	128
ebx            0x0	0
esp            0x7bfe	0x7bfe
ebp            0x0	0x0
esi            0x0	0
edi            0x0	0
eip            0x7c05	0x7c05
eflags         0x202	[ IF ]
cs             0x0	0
ss             0x0	0
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
(gdb) x/1dh 0x7bfe
0x7bfe:	79
</code></pre><p>此时栈中压入一个参数，<code>sp</code>减<code>2</code>，指向<code>0x7bfe</code>。调用函数并查看寄存器中的值：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash"><span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> si
0x00007c0d in ?? <span style="color:#f92672">()</span>
1: x/i $cs*16+$pc
<span style="color:#f92672">=</span>&gt; 0x7c0d:	mov    %sp,%bp
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> info registers
eax            0xaa55	<span style="color:#ae81ff">43605</span>
ecx            0x0	<span style="color:#ae81ff">0</span>
edx            0x80	<span style="color:#ae81ff">128</span>
ebx            0x0	<span style="color:#ae81ff">0</span>
esp            0x7bfc	0x7bfc
ebp            0x0	0x0
esi            0x0	<span style="color:#ae81ff">0</span>
edi            0x0	<span style="color:#ae81ff">0</span>
eip            0x7c0d	0x7c0d
eflags         0x202	<span style="color:#f92672">[</span> IF <span style="color:#f92672">]</span>
cs             0x0	<span style="color:#ae81ff">0</span>
ss             0x0	<span style="color:#ae81ff">0</span>
ds             0x0	<span style="color:#ae81ff">0</span>
es             0x0	<span style="color:#ae81ff">0</span>
fs             0x0	<span style="color:#ae81ff">0</span>
gs             0x0	<span style="color:#ae81ff">0</span>
<span style="color:#f92672">(</span>gdb<span style="color:#f92672">)</span> x/2xh 0x7bfc
0x7bfc:	0x7c08	0x004f
</code></pre></div><p><code>call</code>指令隐式的将<code>ip</code>压栈，<code>sp</code>减<code>2</code>，指向<code>0x7bfc</code>。执行到函数返回，查看寄存器内容：</p>
<pre><code>(gdb) si 14
0x00007c08 in ?? ()
1: x/i $cs*16+$pc
=&gt; 0x7c08:	add    $0x2,%sp
(gdb) info registers
eax            0xaa4f	43599
ecx            0x0	0
edx            0x3d5	981
ebx            0x0	0
esp            0x7bfe	0x7bfe
ebp            0x7bfc	0x7bfc
esi            0x0	0
edi            0x0	0
eip            0x7c08	0x7c08
eflags         0x202	[ IF ]
cs             0x0	0
ss             0x0	0
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
</code></pre><p>此时函数已通过<code>ret</code>指令返回，<code>ip</code>被弹出，<code>sp</code>加<code>2</code>，恢复到压入参数后的状态。继续执行，将<code>sp</code>恢复到参数压栈前：</p>
<pre><code>(gdb) si
0x00007c0b in ?? ()
1: x/i $cs*16+$pc
=&gt; 0x7c0b:	jmp    0x7c0b
(gdb) info registers
eax            0xaa4f	43599
ecx            0x0	0
edx            0x3d5	981
ebx            0x0	0
esp            0x7c00	0x7c00
ebp            0x7bfc	0x7bfc
esi            0x0	0
edi            0x0	0
eip            0x7c0b	0x7c0b
eflags         0x216	[ PF AF IF ]
cs             0x0	0
ss             0x0	0
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
</code></pre><p>虽然我们初步实现了功能，但是可以看到有些寄存器的内容也被我们的函数更改了，例如<code>bp</code>。想想一下，如果我们有多个函数需要嵌套调用，每一个函数都需要通过<code>bp</code>访问堆栈中的参数，每一个函数执行完成之后都会修改<code>bp</code>，那么调用函数的过程就无法再使用<code>bp</code>访问自己的参数了。为了解决这个问题，我们需要将函数中被修改的寄存器先保存在堆栈中，函数返回时再恢复被修改过的寄存器。</p>
<h3 id="参数传递示例3">参数传递示例3</h3>
<p>完整的示例</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#75715e"># 告诉编译器以16位模式编译，因为BIOS在加载并运行我们的代码时是处于16位实地址模式的
</span><span style="color:#75715e"></span><span style="color:#a6e22e">.code16</span>

	<span style="color:#a6e22e">movw</span>	<span style="color:#66d9ef">$0x7c00</span>, %sp	<span style="color:#75715e"># 设置堆栈栈顶指针。因为call指令和ret指令的执行依赖于堆栈。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">pushw</span>	<span style="color:#66d9ef">$79</span>		<span style="color:#75715e"># 将参数79压入栈中，因为一行是80列，从0开始计数，79是第一行的最后一列。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">callw</span>	<span style="color:#66d9ef">set_cursor</span>	<span style="color:#75715e"># 调用set_cursor，注意这里有一个隐含的将ip压栈的操作。
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">addw</span>	<span style="color:#66d9ef">$2</span>, %sp		<span style="color:#75715e"># 用于恢复栈顶指针。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">jmp</span>	.

<span style="color:#75715e"># 目的: 设置光标位置
</span><span style="color:#75715e">#
</span><span style="color:#75715e"># 输入:
</span><span style="color:#75715e">#   参数1 光标所在位置
</span><span style="color:#75715e">#
</span><span style="color:#75715e"># 输出: 无
</span><span style="color:#75715e"></span>set_cursor:
	<span style="color:#a6e22e">pushw</span> %bp
	<span style="color:#a6e22e">movw</span> %sp, %bp	<span style="color:#75715e"># 将当前栈顶指针复制给bp，因为要通过bp间接访问堆栈中的参数。
</span><span style="color:#75715e"></span>
	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d4</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#66d9ef">$0xe</span>, %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#75715e"># 分别通过5(%bp)、4(%bp)访问参数的高8位和低8位。偏移量分别比上一个示例中增加了2，因为多压了bp在栈中。
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d5</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#ae81ff">5</span>(%bp), %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d4</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#66d9ef">$0xf</span>, %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#a6e22e">movw</span> <span style="color:#66d9ef">$0x3d5</span>, %dx
	<span style="color:#a6e22e">movb</span> <span style="color:#ae81ff">4</span>(%bp), %al
	<span style="color:#a6e22e">outb</span> %al, %dx

	<span style="color:#75715e"># 恢复bp
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">movw</span> %bp, %sp
	<span style="color:#a6e22e">popw</span> %bp

	<span style="color:#a6e22e">retw</span>		<span style="color:#75715e"># 通过ret从函数返回，同时将ip出栈，此时堆栈中只剩调用函数之前压入的参数了。
</span><span style="color:#75715e"></span>

	<span style="color:#75715e"># .org伪指令指示编译器把位置计数器移动到操作数所指定的位置，这里是将位置计数器移动到510处
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.org</span>	<span style="color:#ae81ff">510</span>
	<span style="color:#75715e"># .word伪指令指示编译器在当前位置写入一个字大小的数据
</span><span style="color:#75715e"></span>	<span style="color:#a6e22e">.word</span>	<span style="color:#ae81ff">0xaa55</span>
</code></pre></div><p>通常在进入函数和离开函数时都需要保存和恢复<code>bp</code>，即执行下面的指令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">pushw</span> %bp
<span style="color:#a6e22e">movw</span> %sp, %bp

<span style="color:#a6e22e">movw</span> %bp, %sp
<span style="color:#a6e22e">popw</span> %bp
</code></pre></div><p>所以处理器也为我们提供了简化的指令分别对应上面的两组指令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-asm" data-lang="asm"><span style="color:#a6e22e">enterw</span>

<span style="color:#a6e22e">leavew</span>
</code></pre></div><p>完整的示例戳<a href="0x7-6-call-with-args">这里</a>。</p>
<p>关于函数调用之后的<code>sp</code>的恢复除了在调用函数中通过<code>add</code>指令恢复外还可以在被调函数中通过<code>ret</code>指令的操作数来恢复。戳<a href="0x7-7-call-with-args">这里</a></p>
<p>最后再给大家一个功能多一点的<a href="0x7-8-call-with-args">例子</a>。实现了清屏，设置光标位置，获取光标位置，打印字符，打印字符串等功能。比较完整的演示了函数调用中的参数传递，返回值，嵌套调用等情况。示例的输出如下:</p>
<p><img src="./function-call.png" alt=""></p>
<h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://kviccn.github.io/posts/2020/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82-0x07-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/">汇编语言一发入魂 0x07 - 过程调用</a></li>
<li><a href="https://kviccn.github.io/posts/2020/03/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%80%E5%8F%91%E5%85%A5%E9%AD%82-0x08-%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/">汇编语言一发入魂 0x08 - 过程调用中的参数传递</a></li>
</ul>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">laoqinren</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2021-02-26</span>
  </p>
  <p class="copyright-item">
      <span class="item-title">Markdown</span>
      <span class="item-content"><a class="link-to-markdown" href="http://linux.laoqinren.net/posts/007-function-call/index.md" target="_blank">The Markdown version »</a></span>
    </p>
  
</div>

    
    

    <footer class="post-footer">
      

      
      <nav class="post-nav">
        
          <a class="prev" href="/posts/008-interrupt/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">008-中断</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/posts/005-io-interface/">
            <span class="next-text nav-default">005-I/O接口技术</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'laoqinren';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:w@laoqinren.net" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/0x0916" class="iconfont icon-github" title="github"></a>
  <a href="http://linux.laoqinren.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">laoqinren</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>








</body>
</html>
