<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>hungtask 机制分析 - Notes about linux and my work</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="laoqinren" />
  <meta name="description" content="本文分析了内核中hungtask机制，下文中代码基于社区稳定版本内核，版本为：v4.4.128。

" />

  <meta name="keywords" content="Linux, kernel" />






<meta name="generator" content="Hugo 0.37.1" />


<link rel="canonical" href="http://linux.laoqinren.net/kernel/hungtask/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="hungtask 机制分析" />
<meta property="og:description" content="本文分析了内核中hungtask机制，下文中代码基于社区稳定版本内核，版本为：v4.4.128。

" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://linux.laoqinren.net/kernel/hungtask/" />



<meta property="article:published_time" content="2018-04-16T12:14:18&#43;08:00"/>

<meta property="article:modified_time" content="2018-04-16T12:14:18&#43;08:00"/>











<meta itemprop="name" content="hungtask 机制分析">
<meta itemprop="description" content="本文分析了内核中hungtask机制，下文中代码基于社区稳定版本内核，版本为：v4.4.128。

">


<meta itemprop="datePublished" content="2018-04-16T12:14:18&#43;08:00" />
<meta itemprop="dateModified" content="2018-04-16T12:14:18&#43;08:00" />
<meta itemprop="wordCount" content="2532">



<meta itemprop="keywords" content="kernel,linux,hungtask," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="hungtask 机制分析"/>
<meta name="twitter:description" content="本文分析了内核中hungtask机制，下文中代码基于社区稳定版本内核，版本为：v4.4.128。

"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Notes</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/linux/">
        <li class="mobile-menu-item">linux</li>
      </a><a href="/kernel/">
        <li class="mobile-menu-item">Kernel</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Blog</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Notes</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/linux/">linux</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/kernel/">Kernel</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Blog</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/archives/">Archives</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">hungtask 机制分析</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-04-16 </span>
        <div class="post-category">
            
              <a href="/categories/kernel/"> kernel </a>
            
          </div>
        <span class="more-meta"> 2532 words </span>
        <span class="more-meta"> 6 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#相关知识介绍">相关知识介绍</a></li>
<li><a href="#基本原理">基本原理</a></li>
<li><a href="#代码分析">代码分析</a>
<ul>
<li><a href="#初始化函数-hung-task-init">初始化函数<code>hung_task_init</code></a></li>
<li><a href="#内核线程处理-watchdog">内核线程处理：watchdog</a></li>
<li><a href="#check-hung-uninterruptible-tasks">check_hung_uninterruptible_tasks</a></li>
<li><a href="#check-hung-task">check_hung_task()</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>本文分析了内核中<code>hungtask</code>机制，下文中代码基于社区稳定版本内核，版本为：<code>v4.4.128</code>。</p>

<p></p>

<h2 id="相关知识介绍">相关知识介绍</h2>

<p>长期以来，处于<code>D</code>状态(<code>TASK_UNINTERRUPTIBLE</code>状态)的进程都是让人比较烦恼的问题，处于<code>D</code>状态的进程不能接收信号，<code>kill</code>不掉。在一些场景下，常见到进程长期处于<code>D</code>状态，用户对此无能为力，也不知道原因，只能重启恢复。</p>

<p>其实进程长期处于<code>D</code>状态肯定是不正常的，内核中设计<code>D</code>状态的目的是为了让进程等待<code>IO</code>完成，正常情况下<code>IO</code>应该会顺利完成，然后唤醒相应的<code>D</code>状态进程，即使在异常情况下(比如磁盘离或损坏、磁阵链路断开等)，IO处理也是有超时机制的，原理上不会存在永久处于<code>D</code>状态的进程。但是就是因为内核代码流程中可能存在一些<code>bug</code>，或者用户内核模块中的相关机制不合理，可能导致进程长期处于<code>D</code>状态，无法唤醒，类似于死锁状态。</p>

<p>针对这种情况，内核中提供了<code>hung task</code>机制用于检测系统中是否存在处于<code>D</code>状态超过<code>120s</code>(<strong>时长可以设置</strong>)的进程，如果存在，则打印相关警告和进程堆栈。如果配置了<code>hung_task_panic</code>（<code>proc</code>或内核启动参数），则直接发起<code>panic</code>，结合<code>kdump</code>可以搜集到<code>vmcore</code>。从内核的角度看，如果有进程处于<code>D</code>状态的时间超过了<code>120s</code>，那肯定已经出现异常了，以此机制来收集相关的异常信息，用于分析定位问题。</p>

<h2 id="基本原理">基本原理</h2>

<p><code>hung task</code>机制的实现很简单，其基本原理为：创建一个内核线程(<code>khungtaskd</code>)，定期(<code>120</code>)唤醒后，遍历系统中的所有进程，检查是否存在处于<code>D</code>状态超过<code>120s</code>(<strong>时长可以设置</strong>)的进程，如果存在，则打印相关警告和进程堆栈。如果配置了<code>hung_task_panic</code>（<code>proc</code>或内核启动参数），则直接发起<code>panic</code>。</p>

<p>整体流程框图如下：</p>

<p><img src="./hung_task.jpeg" alt="hung_task整体流程" title="hung_task" /></p>

<h2 id="代码分析">代码分析</h2>

<h3 id="初始化函数-hung-task-init">初始化函数<code>hung_task_init</code></h3>

<p>该函数初始化了一个内核线程来检测系统中是否有<code>D</code>状态超过<code>120s</code>的进程</p>

<a target="_blank" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/tree/kernel/hung_task.c?h=v4.4.128#n244"> kernel/hung_task.c(line 244) </a>

<pre><code class="language-c">static int __init hung_task_init(void)
{       
        // 注册通知，当内核panic时，调用函数panic_block
        atomic_notifier_chain_register(&amp;panic_notifier_list, &amp;panic_block);
		// 运行内核线程khungtaskd，其执行方法体为watchdog
        watchdog_task = kthread_run(watchdog, NULL, &quot;khungtaskd&quot;); 

        return 0;
}
subsys_initcall(hung_task_init); 
</code></pre>

<h3 id="内核线程处理-watchdog">内核线程处理：watchdog</h3>

<p>该函数时<code>hung task</code>机制中<code>khungtaskd</code>内核线程的处理函数</p>

<a target="_blank" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/tree/kernel/hung_task.c?h=v4.4.128#n225"> kernel/hung_task.c(line 225) </a>

<pre><code class="language-c">/*
 * kthread which checks for tasks stuck in D state
 */
static int watchdog(void *dummy)
{
        /*设置当前khungtaskd内核线程的nice为0，即普通优先级，为了不影响业务运行 */
        set_user_nice(current, 0);

        for ( ; ; ) {
                /*进程处于D状态的时间上线可通过sysctl/proc控制，默认为120s*/
                unsigned long timeout = sysctl_hung_task_timeout_secs;
                /*检测线程(watchdog)sleep 120s(默认)后，再次唤醒。*/
                while (schedule_timeout_interruptible(timeout_jiffies(timeout)))
                        timeout = sysctl_hung_task_timeout_secs;

                if (atomic_xchg(&amp;reset_hung_task, 0))
                        continue;
                /*醒来后执行实际的检测操作*/
                check_hung_uninterruptible_tasks(timeout);
        }

        return 0;
}

</code></pre>

<h3 id="check-hung-uninterruptible-tasks">check_hung_uninterruptible_tasks</h3>

<p>每隔<code>120s</code>，由<code>check_hung_uninterruptible_tasks</code>来遍历所有的进程，看其是否为<code>D</code>状态，且<code>120s</code>没有被调度。</p>

<a target="_blank" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/tree/kernel/hung_task.c?h=v4.4.128#n158"> kernel/hung_task.c(line 158) </a>

<pre><code class="language-c">/*
 * Check whether a TASK_UNINTERRUPTIBLE does not get woken up for
 * a really long time (120 seconds). If that happens, print out
 * a warning.
 */
static void check_hung_uninterruptible_tasks(unsigned long timeout)
{       /*hung task检测是检查的最大进程数，默认为最大的进程号*/
        int max_count = sysctl_hung_task_check_count;

        /*
        * 每次遍历进程数的上限，默认为1024，这样做的目的是为了:
        * 1、防止rcu_read_lock的占用时间太长。
        * 2、hung task的watchdog占用CPU时间太长。如果没开内核抢占，则如果内核线程不主动调度的话，是不能发生进程切换的?
        */
        /*
        *Fixme:如果系统中的进程数比较多，那么就可能检测不到部分D状态进程了?不会，因为这里只是会调度一次，调度回来
        *后，会继续遍历后面的进程*/
        int batch_count = HUNG_TASK_BATCHING;
        struct task_struct *g, *t;

        /*
         * If the system crashed already then all bets are off,
         * do not report extra hung tasks:
         */
        if (test_taint(TAINT_DIE) || did_panic)/*如果系统已经处于crash状态了，就不在报hung task了。*/
                return;

        rcu_read_lock();
        do_each_thread(g, t) {
                if (!max_count--)
                        goto unlock;
                /*如果每次检测的进程数量超过1024了，则需要发起调度，结束rcu优雅周期*/
                if (!--batch_count) {
                        batch_count = HUNG_TASK_BATCHING;
                        /*释放rcu，并主动调度，调度回来后检查相应进程是否还在，如果不在了，则退出遍历，否则继续*/
                        if (!rcu_lock_break(g, t))
                                goto unlock;
                }
                /* use &quot;==&quot; to skip the TASK_KILLABLE tasks waiting on NFS */
                /*检测进程状态是否为D*/
                if (t-&gt;state == TASK_UNINTERRUPTIBLE)
                        check_hung_task(t, timeout);///*检测进程处于D状态的时间是否超过120s。*/
        } while_each_thread(g, t);
 unlock:
        rcu_read_unlock();
}
</code></pre>

<blockquote>
<p>这里的遍历使用的<code>do_each_thread</code>，它每次都是从<code>init_task</code>进行检测。所以内核<code>demsg</code>中打印出的第一个<code>hung_tasks</code>信息，不一定时第一个成为<code>D</code>状态的进程信息。</p>
</blockquote>

<pre><code class="language-c">#define do_each_thread(g, t) \
        for (g = t = &amp;init_task ; (g = t = next_task(g)) != &amp;init_task ; ) do

#define while_each_thread(g, t) \
        while ((t = next_thread(t)) != g)
</code></pre>

<h3 id="check-hung-task">check_hung_task()</h3>

<p><code>check_hung_task()</code> 用来对给定进程，判断其是否在<code>120s</code>内一值为<code>D</code>状态：</p>

<a target="_blank" href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git/tree/kernel/hung_task.c?h=v4.4.128#n75"> kernel/hung_task.c(line 75) </a>

<pre><code class="language-c">static void check_hung_task(struct task_struct *t, unsigned long timeout)
{       /*进程上下文切换计数，以此来判断该进程是否发生过调度*/
        unsigned long switch_count = t-&gt;nvcsw + t-&gt;nivcsw;

        /*
         * Ensure the task is not frozen.
         * Also, skip vfork and any other user process that freezer should skip.
         */
        if (unlikely(t-&gt;flags &amp; (PF_FROZEN | PF_FREEZER_SKIP)))
            return;

        /*
         * When a freshly created task is scheduled once, changes its state to
         * TASK_UNINTERRUPTIBLE without having ever been switched out once, it
         * musn't be checked.
         */
        if (unlikely(!switch_count))
                return;
    /*
     * 如果当前switch_count不等于last_switch_count，则说明在khungtaskd进程被唤醒期间，
     * 该进程发生过调度。否则的话，说明进程没有发生过调度
     * 也就是说，该进程一直处于D状态，因为last_switch_count只在这里更新，其它地方不会。
     * hung task机制中的120s其实是通过khungtaskd内核线程的唤醒周期来控制的。
     */
        if (switch_count != t-&gt;last_switch_count) {
                /*更新last_switch_count计数，只在这里更新，该计数专用于hung task的检测。*/
                t-&gt;last_switch_count = switch_count;
                return;
        }

        trace_sched_process_hang(t);
    /*
     * hung task错误打印次数限制，防止dos攻击。默认为10次，由于是全局变量，
     * 表示系统运行期间最多打印10次，超过后就不打印了。该参数应该可以
     * 通过sysctl修改
     */
        if (!sysctl_hung_task_warnings)
                return;

        if (sysctl_hung_task_warnings &gt; 0)
                sysctl_hung_task_warnings--;
        /*
         * Ok, the task did not get scheduled for more than 2 minutes,
         * complain:
         */
        pr_err(&quot;INFO: task %s:%d blocked for more than %ld seconds.\n&quot;,
                t-&gt;comm, t-&gt;pid, timeout);
        pr_err(&quot;      %s %s %.*s\n&quot;,
                print_tainted(), init_utsname()-&gt;release,
                (int)strcspn(init_utsname()-&gt;version, &quot; &quot;),
                init_utsname()-&gt;version);
        pr_err(&quot;\&quot;echo 0 &gt; /proc/sys/kernel/hung_task_timeout_secs\&quot;&quot;
                &quot; disables this message.\n&quot;);
		/*打印堆栈*/
        sched_show_task(t);
		/*如果开启了debug_lock，则打印锁的占用情况*/
        debug_show_held_locks(t);

        /*touch nmi_watchdog相关的计数器，防止在此过程中触发nmi_watchdog*/
        touch_nmi_watchdog();

        /*检测是否配置了/proc/sys/kernel/hung_task_panic，如果配置则直接触发panic*/
        if (sysctl_hung_task_panic) {
                /*打印所有CPU的堆栈*/
                trigger_all_cpu_backtrace();
                /*触发panic，如果配置了kdump就有用了*/
                panic(&quot;hung_task: blocked tasks&quot;);
        }
}
</code></pre>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">laoqinren</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-04-16</span>
  </p>
  <p class="copyright-item">
      <span class="item-title">Markdown</span>
      <span class="item-content"><a class="link-to-markdown" href="http://linux.laoqinren.net/kernel/hungtask/index.md" target="_blank">The Markdown version »</a></span>
    </p>
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/kernel/">kernel</a>
          
          <a href="/tags/linux/">linux</a>
          
          <a href="/tags/hungtask/">hungtask</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/kernel/floating-proportions/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Floating proportions with flexible aging period</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/kernel/percpu-counter/">
            <span class="next-text nav-default">内核基础设施——percpu_counter</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'laoqinren';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:w@laoqinren.net" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/0x0916" class="iconfont icon-github" title="github"></a>
  <a href="http://linux.laoqinren.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2018
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">laoqinren</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>








</body>
</html>
