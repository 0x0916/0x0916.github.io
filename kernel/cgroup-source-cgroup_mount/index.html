<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>cgroup源码分析3——cgroup层级的mount流程 - Notes about linux and my work</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="laoqinren" />
  <meta name="description" content="本文继续该系列文章，分析了cgroup各个子系统的mount流程，当然也包括umount/remount流程。
 注意：本文基于3.10.0-862.el7.x86_64版本kernel进行分析。
" />

  <meta name="keywords" content="Linux, kernel" />






<meta name="generator" content="Hugo 0.80.0" />


<link rel="canonical" href="http://linux.laoqinren.net/kernel/cgroup-source-cgroup_mount/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="cgroup源码分析3——cgroup层级的mount流程" />
<meta property="og:description" content="本文继续该系列文章，分析了cgroup各个子系统的mount流程，当然也包括umount/remount流程。

注意：本文基于3.10.0-862.el7.x86_64版本kernel进行分析。
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://linux.laoqinren.net/kernel/cgroup-source-cgroup_mount/" />
<meta property="article:published_time" content="2018-08-25T10:54:09+08:00" />
<meta property="article:modified_time" content="2018-08-25T10:54:09+08:00" />
<meta itemprop="name" content="cgroup源码分析3——cgroup层级的mount流程">
<meta itemprop="description" content="本文继续该系列文章，分析了cgroup各个子系统的mount流程，当然也包括umount/remount流程。

注意：本文基于3.10.0-862.el7.x86_64版本kernel进行分析。
">
<meta itemprop="datePublished" content="2018-08-25T10:54:09+08:00" />
<meta itemprop="dateModified" content="2018-08-25T10:54:09+08:00" />
<meta itemprop="wordCount" content="4327">



<meta itemprop="keywords" content="kernel,linux,cgroup," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="cgroup源码分析3——cgroup层级的mount流程"/>
<meta name="twitter:description" content="本文继续该系列文章，分析了cgroup各个子系统的mount流程，当然也包括umount/remount流程。

注意：本文基于3.10.0-862.el7.x86_64版本kernel进行分析。
"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Notes</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/linux/">
        <li class="mobile-menu-item">linux</li>
      </a><a href="/kernel/">
        <li class="mobile-menu-item">Kernel</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Blog</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Notes</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/linux/">linux</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/kernel/">Kernel</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Blog</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/archives/">Archives</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">cgroup源码分析3——cgroup层级的mount流程</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-08-25 </span>
        <div class="post-category">
            
              <a href="/categories/kernel/"> kernel </a>
            
              <a href="/categories/cgroup/"> cgroup </a>
            
          </div>
        <span class="more-meta"> 4327 words </span>
        <span class="more-meta"> 9 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#mount流程整体流程介绍">mount流程整体流程介绍</a></li>
        <li><a href="#mount中的一些细节">mount中的一些细节</a></li>
        <li><a href="#rebind_subsystem">rebind_subsystem</a></li>
        <li><a href="#remount的一些限制">remount的一些限制</a></li>
        <li><a href="#umount">umount</a></li>
        <li><a href="#参考文章">参考文章</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>本文继续该系列文章，分析了<code>cgroup</code>各个子系统的<code>mount</code>流程，当然也包括<code>umount/remount</code>流程。</p>
<blockquote>
<p>注意：本文基于<code>3.10.0-862.el7.x86_64</code>版本<code>kernel</code>进行分析。</p>
</blockquote>
<h3 id="mount流程整体流程介绍">mount流程整体流程介绍</h3>
<p>当我们mount <code>cgroup</code>文件系统时，一般输入命令如下：</p>
<pre><code># mount -t cgroup -o cpu,cpuacct   none  /sys/fs/cgroup/cpu,cpuacct
# mount -t cgroup -o pids none /sysfs/cgroup/cpu,cpuacct
</code></pre><p>在内核中，执行的函数为<code>cgroup_mount</code>，其主要完成了如下工作：</p>
<ul>
<li>执行<code>parse_cgroupfs_options</code> 解析<code>mount</code>时的<code>options</code>选项</li>
<li>执行<code>cgroup_root_from_opts</code> 分配一个新的<code>cgroupfs_root</code></li>
<li>通过<code>sget</code>查找对应的<code>super_block</code>是否存在，如果不存在就创建一个新的<code>super_block</code></li>
<li>如果<code>cgroupfs_root</code>已经存在，则说明已经挂载了，这次不需要做什么。</li>
<li>如果是新创建的<code>cgroupfs_root</code>，则说明没有挂载，需要做如下事情：</li>
</ul>
<ul>
<li>获取挂载点对应的<code>inode</code></li>
<li>分配<code>css_set_count</code>个<code>cg_cgroup_link</code>结构</li>
<li><code>rebind_subsystem</code></li>
<li>将该<code>cgroupfs_root</code>添加到链表<code>roots</code>中</li>
<li>根据该层级的配置，使用<code>cgroup_populate_dir</code>创建对应的<code>cgroup</code>控制文件</li>
</ul>
<p>代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> dentry <span style="color:#f92672">*</span><span style="color:#a6e22e">cgroup_mount</span>(<span style="color:#66d9ef">struct</span> file_system_type <span style="color:#f92672">*</span>fs_type,
			 <span style="color:#66d9ef">int</span> flags, <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>unused_dev_name,
			 <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data)
{
	<span style="color:#66d9ef">struct</span> cgroup_sb_opts opts;
	<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>root;
	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">struct</span> super_block <span style="color:#f92672">*</span>sb;
	<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>new_root;
	<span style="color:#66d9ef">struct</span> inode <span style="color:#f92672">*</span>inode;

	<span style="color:#75715e">/* First find the desired set of subsystems */</span>
	mutex_lock(<span style="color:#f92672">&amp;</span>cgroup_mutex);
	ret <span style="color:#f92672">=</span> parse_cgroupfs_options(data, <span style="color:#f92672">&amp;</span>opts);
	mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_mutex);
	<span style="color:#66d9ef">if</span> (ret)
		<span style="color:#66d9ef">goto</span> out_err;

	<span style="color:#75715e">/*
</span><span style="color:#75715e">	 * Allocate a new cgroup root. We may not need it if we&#39;re
</span><span style="color:#75715e">	 * reusing an existing hierarchy.
</span><span style="color:#75715e">	 */</span>
	new_root <span style="color:#f92672">=</span> cgroup_root_from_opts(<span style="color:#f92672">&amp;</span>opts); <span style="color:#75715e">// 解析mount时的options选项
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (IS_ERR(new_root)) {
		ret <span style="color:#f92672">=</span> PTR_ERR(new_root);
		<span style="color:#66d9ef">goto</span> drop_modules;
	}
	opts.new_root <span style="color:#f92672">=</span> new_root;

	<span style="color:#75715e">/* Locate an existing or new sb for this hierarchy */</span><span style="color:#75715e">// 分配一个新的cgroupfs_root
</span><span style="color:#75715e"></span>	sb <span style="color:#f92672">=</span> sget(fs_type, cgroup_test_super, cgroup_set_super, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">&amp;</span>opts);
	<span style="color:#66d9ef">if</span> (IS_ERR(sb)) {
		ret <span style="color:#f92672">=</span> PTR_ERR(sb);
		cgroup_drop_root(opts.new_root);
		<span style="color:#66d9ef">goto</span> drop_modules;
	}

	root <span style="color:#f92672">=</span> sb<span style="color:#f92672">-&gt;</span>s_fs_info;
	BUG_ON(<span style="color:#f92672">!</span>root);
	<span style="color:#66d9ef">if</span> (root <span style="color:#f92672">==</span> opts.new_root) { <span style="color:#75715e">// 新的挂载，说明这是一个新的层级
</span><span style="color:#75715e"></span>		<span style="color:#75715e">/* We used the new root structure, so this is a new hierarchy */</span>
		<span style="color:#66d9ef">struct</span> list_head tmp_cg_links;
		<span style="color:#66d9ef">struct</span> cgroup <span style="color:#f92672">*</span>root_cgrp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>top_cgroup;
		<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>existing_root;
		<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> cred <span style="color:#f92672">*</span>cred;
		<span style="color:#66d9ef">int</span> i;
		<span style="color:#66d9ef">struct</span> css_set <span style="color:#f92672">*</span>cg;

		BUG_ON(sb<span style="color:#f92672">-&gt;</span>s_root <span style="color:#f92672">!=</span> NULL);
		<span style="color:#75715e">// 获取挂载点的inode
</span><span style="color:#75715e"></span>		ret <span style="color:#f92672">=</span> cgroup_get_rootdir(sb);
		<span style="color:#66d9ef">if</span> (ret)
			<span style="color:#66d9ef">goto</span> drop_new_super;
		inode <span style="color:#f92672">=</span> sb<span style="color:#f92672">-&gt;</span>s_root<span style="color:#f92672">-&gt;</span>d_inode;

		mutex_lock(<span style="color:#f92672">&amp;</span>inode<span style="color:#f92672">-&gt;</span>i_mutex);
		mutex_lock(<span style="color:#f92672">&amp;</span>cgroup_mutex);
		mutex_lock(<span style="color:#f92672">&amp;</span>cgroup_root_mutex);

		<span style="color:#75715e">/* Check for name clashes with existing mounts */</span>
		ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EBUSY;
		<span style="color:#66d9ef">if</span> (strlen(root<span style="color:#f92672">-&gt;</span>name))
			for_each_active_root(existing_root)
				<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>strcmp(existing_root<span style="color:#f92672">-&gt;</span>name, root<span style="color:#f92672">-&gt;</span>name))
					<span style="color:#66d9ef">goto</span> unlock_drop;

		<span style="color:#75715e">/*
</span><span style="color:#75715e">		 * We&#39;re accessing css_set_count without locking
</span><span style="color:#75715e">		 * css_set_lock here, but that&#39;s OK - it can only be
</span><span style="color:#75715e">		 * increased by someone holding cgroup_lock, and
</span><span style="color:#75715e">		 * that&#39;s us. The worst that can happen is that we
</span><span style="color:#75715e">		 * have some link structures left over
</span><span style="color:#75715e">		 */</span><span style="color:#75715e">// 分配css_set_count个cg_cgroup_link结构
</span><span style="color:#75715e"></span>		ret <span style="color:#f92672">=</span> allocate_cg_links(css_set_count, <span style="color:#f92672">&amp;</span>tmp_cg_links);
		<span style="color:#66d9ef">if</span> (ret)
			<span style="color:#66d9ef">goto</span> unlock_drop;

		ret <span style="color:#f92672">=</span> rebind_subsystems(root, root<span style="color:#f92672">-&gt;</span>subsys_mask);
		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>EBUSY) {
			free_cg_links(<span style="color:#f92672">&amp;</span>tmp_cg_links);
			<span style="color:#66d9ef">goto</span> unlock_drop;
		}
		<span style="color:#75715e">/*
</span><span style="color:#75715e">		 * There must be no failure case after here, since rebinding
</span><span style="color:#75715e">		 * takes care of subsystems&#39; refcounts, which are explicitly
</span><span style="color:#75715e">		 * dropped in the failure exit path.
</span><span style="color:#75715e">		 */</span>

		<span style="color:#75715e">/* EBUSY should be the only error here */</span>
		BUG_ON(ret);
		<span style="color:#75715e">// 将该cgroupfs_root添加到链表roots中
</span><span style="color:#75715e"></span>		list_add(<span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>root_list, <span style="color:#f92672">&amp;</span>roots);
		root_count<span style="color:#f92672">++</span>;

		sb<span style="color:#f92672">-&gt;</span>s_root<span style="color:#f92672">-&gt;</span>d_fsdata <span style="color:#f92672">=</span> root_cgrp;
		root<span style="color:#f92672">-&gt;</span>top_cgroup.dentry <span style="color:#f92672">=</span> sb<span style="color:#f92672">-&gt;</span>s_root;

		<span style="color:#75715e">/* Link the top cgroup in this hierarchy into all
</span><span style="color:#75715e">		 * the css_set objects */</span>
		write_lock(<span style="color:#f92672">&amp;</span>css_set_lock);
		hash_for_each(css_set_table, i, cg, hlist)
			link_css_set(<span style="color:#f92672">&amp;</span>tmp_cg_links, cg, root_cgrp);
		write_unlock(<span style="color:#f92672">&amp;</span>css_set_lock);

		free_cg_links(<span style="color:#f92672">&amp;</span>tmp_cg_links);

		BUG_ON(<span style="color:#f92672">!</span>list_empty(<span style="color:#f92672">&amp;</span>root_cgrp<span style="color:#f92672">-&gt;</span>children));
		BUG_ON(root<span style="color:#f92672">-&gt;</span>number_of_cgroups <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>);

		cred <span style="color:#f92672">=</span> override_creds(<span style="color:#f92672">&amp;</span>init_cred);
		<span style="color:#75715e">// 创建对应的cgroup控制文件
</span><span style="color:#75715e"></span>		cgroup_populate_dir(root_cgrp, true, root<span style="color:#f92672">-&gt;</span>subsys_mask);
		revert_creds(cred);
		mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_root_mutex);
		mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_mutex);
		mutex_unlock(<span style="color:#f92672">&amp;</span>inode<span style="color:#f92672">-&gt;</span>i_mutex);
	} <span style="color:#66d9ef">else</span> { <span style="color:#75715e">// 已经挂载了，不需要做什么
</span><span style="color:#75715e"></span>		<span style="color:#75715e">/*
</span><span style="color:#75715e">		 * We re-used an existing hierarchy - the new root (if
</span><span style="color:#75715e">		 * any) is not needed
</span><span style="color:#75715e">		 */</span>
		cgroup_drop_root(opts.new_root);

		<span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">!=</span> opts.flags) {
			<span style="color:#66d9ef">if</span> ((root<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">|</span> opts.flags) <span style="color:#f92672">&amp;</span> CGRP_ROOT_SANE_BEHAVIOR) {
				pr_err(<span style="color:#e6db74">&#34;cgroup: sane_behavior: new mount options should match the existing superblock</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
				ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EINVAL;
				<span style="color:#66d9ef">goto</span> drop_new_super;
			} <span style="color:#66d9ef">else</span> {
				pr_warning(<span style="color:#e6db74">&#34;cgroup: new mount options do not match the existing superblock, will be ignored</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
			}
		}

		<span style="color:#75715e">/* no subsys rebinding, so refcounts don&#39;t change */</span>
		drop_parsed_module_refcounts(opts.subsys_mask);
	}

	kfree(opts.release_agent);
	kfree(opts.name);
	<span style="color:#66d9ef">return</span> dget(sb<span style="color:#f92672">-&gt;</span>s_root);

 unlock_drop:
	mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_root_mutex);
	mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_mutex);
	mutex_unlock(<span style="color:#f92672">&amp;</span>inode<span style="color:#f92672">-&gt;</span>i_mutex);
 drop_new_super:
	deactivate_locked_super(sb);
 drop_modules:
	drop_parsed_module_refcounts(opts.subsys_mask);
 out_err:
	kfree(opts.release_agent);
	kfree(opts.name);
	<span style="color:#66d9ef">return</span> ERR_PTR(ret);
}

</code></pre></div><p>在<code>centos 7 </code>系统启动时，默认会挂载所有的<code>cgroup</code>子系统，这些子系统是由<code>systemd</code>来负责挂载的，其代码为：<a href="https://github.com/systemd/systemd/blob/v219/src/core/mount-setup.c#L222L316">mount_cgroup_controllers</a></p>
<h3 id="mount中的一些细节">mount中的一些细节</h3>
<h4 id="解析mount选项">解析mount选项</h4>
<p><code>parse_cgroupfs_options</code> 函数对mount时的options进行了解析，最后将结果保存到了一个cgroup_sb_opts类型的结构，并返回。</p>
<p>该版本的kernel支持的选项包括：</p>
<ul>
<li>none</li>
<li>all</li>
<li>__DEVEL__sane_behavior</li>
<li>noprefix</li>
<li>clone_children</li>
<li>cpuset_v2_mode</li>
<li>xattr</li>
<li>release_agent=</li>
<li>name=</li>
<li>cgroup子系统的名称</li>
</ul>
<p>这些选项受如下约束：</p>
<ul>
<li>只能指定一个<code>release_agent=</code></li>
<li><code>name=</code>的值中只允许为字母、数字和符号<code>.</code>, <code>-</code>, <code>_</code>等</li>
<li><code>all和</code>cgroup<code>子系统的名互斥，指定了</code>all<code>，就不能在指定</code>cgroup`子系统的名称了</li>
<li><code>none</code>和<code>cgroup</code>子系统的名互斥，指定了<code>none</code>，就不能在指定<code>cgroup</code>子系统的名称了</li>
<li>当指定了<code>__DEVEL__sane_behavior</code>后，就不能再指定<code>clone_children</code>和<code>noprefix</code>了</li>
<li>指定<code>noprefix</code>时，必须是在mount  <code>cpuset</code>这个控制器</li>
</ul>
<p>在<code>parse_cgroupfs_options</code>的最后，会将这些需要挂载的<code>cgroup</code>控制器的模块引用计数<strong>加1</strong>，防止被别人意外卸载。</p>
<h4 id="init_root_id-获取分配的层级的id">init_root_id 获取分配的层级的id</h4>
<p><code>cgroup_root_from_opts</code>函数根据挂载选项的要求，创建新的<code>cgroupfs_root</code>结构，如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span><span style="color:#a6e22e">cgroup_root_from_opts</span>(<span style="color:#66d9ef">struct</span> cgroup_sb_opts <span style="color:#f92672">*</span>opts)
{
	<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>root;

	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>opts<span style="color:#f92672">-&gt;</span>subsys_mask <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>opts<span style="color:#f92672">-&gt;</span>none)
		<span style="color:#66d9ef">return</span> NULL;

	root <span style="color:#f92672">=</span> kzalloc(<span style="color:#66d9ef">sizeof</span>(<span style="color:#f92672">*</span>root), GFP_KERNEL);
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root)
		<span style="color:#66d9ef">return</span> ERR_PTR(<span style="color:#f92672">-</span>ENOMEM);

	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>init_root_id(root)) { <span style="color:#75715e">// 重点
</span><span style="color:#75715e"></span>		kfree(root);
		<span style="color:#66d9ef">return</span> ERR_PTR(<span style="color:#f92672">-</span>ENOMEM);
	}
	init_cgroup_root(root);

	root<span style="color:#f92672">-&gt;</span>subsys_mask <span style="color:#f92672">=</span> opts<span style="color:#f92672">-&gt;</span>subsys_mask;
	root<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">=</span> opts<span style="color:#f92672">-&gt;</span>flags;
	ida_init(<span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>cgroup_ida);
	<span style="color:#66d9ef">if</span> (opts<span style="color:#f92672">-&gt;</span>release_agent)
		strcpy(root<span style="color:#f92672">-&gt;</span>release_agent_path, opts<span style="color:#f92672">-&gt;</span>release_agent);
	<span style="color:#66d9ef">if</span> (opts<span style="color:#f92672">-&gt;</span>name)
		strcpy(root<span style="color:#f92672">-&gt;</span>name, opts<span style="color:#f92672">-&gt;</span>name);
	<span style="color:#66d9ef">if</span> (opts<span style="color:#f92672">-&gt;</span>cpuset_clone_children)
		set_bit(CGRP_CPUSET_CLONE_CHILDREN, <span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>top_cgroup.flags);
	<span style="color:#66d9ef">return</span> root;
}
</code></pre></div><p><code>init_root_id</code> 用来为该<code>cgroupfs_root</code>分配一个唯一的id。其利用了内核基础设置<code>IDA</code>机制，对应到cgroup里有以下几个全局变量：</p>
<pre><code>static DEFINE_IDA(hierarchy_ida);
static int next_hierarchy_id;
static DEFINE_SPINLOCK(hierarchy_id_lock);
</code></pre><p><code>hierarchy_id_lock</code> 用来包含对<code>next_hierarchy_id</code> 和 <code>hierarchy_ida</code>的访问，<code>next_hierarchy_id</code>表示下一次需要分配的<code>id</code>号。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">init_root_id</span>(<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>root)
{
	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">do</span> {
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ida_pre_get(<span style="color:#f92672">&amp;</span>hierarchy_ida, GFP_KERNEL))
			<span style="color:#66d9ef">return</span> false;
		spin_lock(<span style="color:#f92672">&amp;</span>hierarchy_id_lock);
		<span style="color:#75715e">/* Try to allocate the next unused ID */</span>
		ret <span style="color:#f92672">=</span> ida_get_new_above(<span style="color:#f92672">&amp;</span>hierarchy_ida, next_hierarchy_id,
					<span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>hierarchy_id);
		<span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">==</span> <span style="color:#f92672">-</span>ENOSPC)
			<span style="color:#75715e">/* Try again starting from 0 */</span>
			ret <span style="color:#f92672">=</span> ida_get_new(<span style="color:#f92672">&amp;</span>hierarchy_ida, <span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>hierarchy_id);
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>ret) {
			next_hierarchy_id <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>hierarchy_id <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (ret <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>EAGAIN) {
			<span style="color:#75715e">/* Can only get here if the 31-bit IDR is full ... */</span>
			BUG_ON(ret);
		}
		spin_unlock(<span style="color:#f92672">&amp;</span>hierarchy_id_lock);
	} <span style="color:#66d9ef">while</span> (ret);
	<span style="color:#66d9ef">return</span> true;
}
</code></pre></div><h4 id="sget-查找对应的super_block是否存在">sget 查找对应的super_block是否存在</h4>
<p>sget 查找对应的super_block是否存时，用到了两个方法<code>cgroup_test_super</code>和<code>cgroup_set_super</code>:</p>
<ul>
<li><code>cgroup_test_super</code>用于判断super_block是否相等</li>
</ul>
<p>当有name时，name必须相等，此外cgroupfs_root上挂载的cgroup子系统也完全相同时，这两个super_block才相等</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cgroup_test_super</span>(<span style="color:#66d9ef">struct</span> super_block <span style="color:#f92672">*</span>sb, <span style="color:#66d9ef">void</span> <span style="color:#f92672">*</span>data)
{
	<span style="color:#66d9ef">struct</span> cgroup_sb_opts <span style="color:#f92672">*</span>opts <span style="color:#f92672">=</span> data;
	<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> sb<span style="color:#f92672">-&gt;</span>s_fs_info;

	<span style="color:#75715e">/* If we asked for a name then it must match */</span>
	<span style="color:#66d9ef">if</span> (opts<span style="color:#f92672">-&gt;</span>name <span style="color:#f92672">&amp;&amp;</span> strcmp(opts<span style="color:#f92672">-&gt;</span>name, root<span style="color:#f92672">-&gt;</span>name))
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#75715e">/*
</span><span style="color:#75715e">	 * If we asked for subsystems (or explicitly for no
</span><span style="color:#75715e">	 * subsystems) then they must match
</span><span style="color:#75715e">	 */</span>
	<span style="color:#66d9ef">if</span> ((opts<span style="color:#f92672">-&gt;</span>subsys_mask <span style="color:#f92672">||</span> opts<span style="color:#f92672">-&gt;</span>none)
	    <span style="color:#f92672">&amp;&amp;</span> (opts<span style="color:#f92672">-&gt;</span>subsys_mask <span style="color:#f92672">!=</span> root<span style="color:#f92672">-&gt;</span>subsys_mask))
		<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;
}
</code></pre></div><ul>
<li><code>cgroup_set_super</code>的目的是设置新创建的<code>super_block</code>的一些属性</li>
</ul>
<pre><code>static int cgroup_set_super(struct super_block *sb, void *data)
{
	int ret;
	struct cgroup_sb_opts *opts = data;

	/* If we don't have a new root, we can't set up a new sb */
	if (!opts-&gt;new_root)
		return -EINVAL;

	BUG_ON(!opts-&gt;subsys_mask &amp;&amp; !opts-&gt;none);

	ret = set_anon_super(sb, NULL);
	if (ret)
		return ret;

	sb-&gt;s_fs_info = opts-&gt;new_root;
	opts-&gt;new_root-&gt;sb = sb;

	sb-&gt;s_blocksize = PAGE_CACHE_SIZE;
	sb-&gt;s_blocksize_bits = PAGE_CACHE_SHIFT;
	sb-&gt;s_magic = CGROUP_SUPER_MAGIC;
	sb-&gt;s_op = &amp;cgroup_ops;

	return 0;
}
</code></pre><p>看这里的<code>cgroup_ops</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">struct</span> super_operations cgroup_ops <span style="color:#f92672">=</span> {
	.statfs <span style="color:#f92672">=</span> simple_statfs,
	.drop_inode <span style="color:#f92672">=</span> generic_delete_inode,
	.show_options <span style="color:#f92672">=</span> cgroup_show_options,
	.remount_fs <span style="color:#f92672">=</span> cgroup_remount,
};
</code></pre></div><p>后续remount操作时，调用的就是这里的钩子函数<code>cgroup_remount</code>。</p>
<h3 id="rebind_subsystem">rebind_subsystem</h3>
<p><code>rebind_subsystem</code>比较关键，其实现的功能时：</p>
<ul>
<li>计算这次<code>mount</code>时，需要添加的<code>cgroup</code>子系统和要删除的<code>cgroup</code>子系统</li>
<li>检查要添加的<code>cgroup</code>子系统是否是空闲的，如果不是，则返回EBUSY`</li>
<li>检查<code>cgroupfs_root</code>是否只有一个<code>cgroup</code>，即只有<code>root cgroup</code>。否则返回<code>EBUSY</code></li>
<li>然后处理每一个<code>cgroup子系统</code></li>
</ul>
<ul>
<li>需要添加<code>cgroup子系统</code>的话：将<code>cgroup_subsys</code>从<code>rootnode</code>的<code>subsys_list</code>中移动到新创建的<code>cgroupfs_root</code>的subsys_list中等；</li>
<li>需要删除<code>cgroup子系统</code>的话：将<code>cgroup_subsys</code>从<code>cgroupfs_root</code>的<code>subsys_list</code>移动到<code>rootnode</code>的<code>subsys_list</code>中；</li>
<li>不添加也不删除<code>cgroup</code>子系统的话：减少模块的引用计数，因为<code>parse_cgroupfs_options</code>中已经将其引用计数<code>加1</code>了</li>
<li>其他：不做任何操作</li>
</ul>
<p>当然，在添加和删除<code>cgroup子系统</code>时，会调整一下<code>cgroup_subsys</code>的<code>root</code>成员的值和<code>root cgroup</code>的成员<code>subsys</code>的值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * Call with cgroup_mutex held. Drops reference counts on modules, including
</span><span style="color:#75715e"> * any duplicate ones that parse_cgroupfs_options took. If this function
</span><span style="color:#75715e"> * returns an error, no reference counts are touched.
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">rebind_subsystems</span>(<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>root,
			      <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> final_subsys_mask)
{
	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> added_mask, removed_mask;
	<span style="color:#66d9ef">struct</span> cgroup <span style="color:#f92672">*</span>cgrp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>top_cgroup;
	<span style="color:#66d9ef">int</span> i;

	BUG_ON(<span style="color:#f92672">!</span>mutex_is_locked(<span style="color:#f92672">&amp;</span>cgroup_mutex));
	BUG_ON(<span style="color:#f92672">!</span>mutex_is_locked(<span style="color:#f92672">&amp;</span>cgroup_root_mutex));

	removed_mask <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>actual_subsys_mask <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>final_subsys_mask;
	added_mask <span style="color:#f92672">=</span> final_subsys_mask <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>root<span style="color:#f92672">-&gt;</span>actual_subsys_mask;
	<span style="color:#75715e">/* Check that any added subsystems are currently free */</span>
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> CGROUP_SUBSYS_COUNT; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> bit <span style="color:#f92672">=</span> <span style="color:#ae81ff">1UL</span> <span style="color:#f92672">&lt;&lt;</span> i;
		<span style="color:#66d9ef">struct</span> cgroup_subsys <span style="color:#f92672">*</span>ss <span style="color:#f92672">=</span> subsys[i];
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>(bit <span style="color:#f92672">&amp;</span> added_mask))
			<span style="color:#66d9ef">continue</span>;
		<span style="color:#75715e">/*
</span><span style="color:#75715e">		 * Nobody should tell us to do a subsys that doesn&#39;t exist:
</span><span style="color:#75715e">		 * parse_cgroupfs_options should catch that case and refcounts
</span><span style="color:#75715e">		 * ensure that subsystems won&#39;t disappear once selected.
</span><span style="color:#75715e">		 */</span>
		BUG_ON(ss <span style="color:#f92672">==</span> NULL);
		<span style="color:#66d9ef">if</span> (ss<span style="color:#f92672">-&gt;</span>root <span style="color:#f92672">!=</span> <span style="color:#f92672">&amp;</span>rootnode) {
			<span style="color:#75715e">/* Subsystem isn&#39;t free */</span>
			<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EBUSY;
		}
	}

	<span style="color:#75715e">/* Currently we don&#39;t handle adding/removing subsystems when
</span><span style="color:#75715e">	 * any child cgroups exist. This is theoretically supportable
</span><span style="color:#75715e">	 * but involves complex error handling, so it&#39;s being left until
</span><span style="color:#75715e">	 * later */</span>
	<span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>number_of_cgroups <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1</span>)
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EBUSY;

	<span style="color:#75715e">/* Process each subsystem */</span>
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> CGROUP_SUBSYS_COUNT; i<span style="color:#f92672">++</span>) {
		<span style="color:#66d9ef">struct</span> cgroup_subsys <span style="color:#f92672">*</span>ss <span style="color:#f92672">=</span> subsys[i];
		<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> bit <span style="color:#f92672">=</span> <span style="color:#ae81ff">1UL</span> <span style="color:#f92672">&lt;&lt;</span> i;
		<span style="color:#66d9ef">if</span> (bit <span style="color:#f92672">&amp;</span> added_mask) {
			<span style="color:#75715e">/* We&#39;re binding this subsystem to this hierarchy */</span>
			BUG_ON(ss <span style="color:#f92672">==</span> NULL);
			BUG_ON(cgrp<span style="color:#f92672">-&gt;</span>subsys[i]);
			BUG_ON(<span style="color:#f92672">!</span>dummytop<span style="color:#f92672">-&gt;</span>subsys[i]);
			BUG_ON(dummytop<span style="color:#f92672">-&gt;</span>subsys[i]<span style="color:#f92672">-&gt;</span>cgroup <span style="color:#f92672">!=</span> dummytop);
			cgrp<span style="color:#f92672">-&gt;</span>subsys[i] <span style="color:#f92672">=</span> dummytop<span style="color:#f92672">-&gt;</span>subsys[i];
			cgrp<span style="color:#f92672">-&gt;</span>subsys[i]<span style="color:#f92672">-&gt;</span>cgroup <span style="color:#f92672">=</span> cgrp;
			list_move(<span style="color:#f92672">&amp;</span>ss<span style="color:#f92672">-&gt;</span>sibling, <span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>subsys_list);
			ss<span style="color:#f92672">-&gt;</span>root <span style="color:#f92672">=</span> root;
			<span style="color:#66d9ef">if</span> (ss<span style="color:#f92672">-&gt;</span>bind)
				ss<span style="color:#f92672">-&gt;</span>bind(cgrp);
			<span style="color:#75715e">/* refcount was already taken, and we&#39;re keeping it */</span>
		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bit <span style="color:#f92672">&amp;</span> removed_mask) {
			<span style="color:#75715e">/* We&#39;re removing this subsystem */</span>
			BUG_ON(ss <span style="color:#f92672">==</span> NULL);
			BUG_ON(cgrp<span style="color:#f92672">-&gt;</span>subsys[i] <span style="color:#f92672">!=</span> dummytop<span style="color:#f92672">-&gt;</span>subsys[i]);
			BUG_ON(cgrp<span style="color:#f92672">-&gt;</span>subsys[i]<span style="color:#f92672">-&gt;</span>cgroup <span style="color:#f92672">!=</span> cgrp);
			<span style="color:#66d9ef">if</span> (ss<span style="color:#f92672">-&gt;</span>bind)
				ss<span style="color:#f92672">-&gt;</span>bind(dummytop);
			dummytop<span style="color:#f92672">-&gt;</span>subsys[i]<span style="color:#f92672">-&gt;</span>cgroup <span style="color:#f92672">=</span> dummytop;
			cgrp<span style="color:#f92672">-&gt;</span>subsys[i] <span style="color:#f92672">=</span> NULL;
			subsys[i]<span style="color:#f92672">-&gt;</span>root <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>rootnode;
			list_move(<span style="color:#f92672">&amp;</span>ss<span style="color:#f92672">-&gt;</span>sibling, <span style="color:#f92672">&amp;</span>rootnode.subsys_list);
			<span style="color:#75715e">/* subsystem is now free - drop reference on module */</span>
			module_put(ss<span style="color:#f92672">-&gt;</span>module);
		} <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (bit <span style="color:#f92672">&amp;</span> final_subsys_mask) {
			<span style="color:#75715e">/* Subsystem state should already exist */</span>
			BUG_ON(ss <span style="color:#f92672">==</span> NULL);
			BUG_ON(<span style="color:#f92672">!</span>cgrp<span style="color:#f92672">-&gt;</span>subsys[i]);
			<span style="color:#75715e">/*
</span><span style="color:#75715e">			 * a refcount was taken, but we already had one, so
</span><span style="color:#75715e">			 * drop the extra reference.
</span><span style="color:#75715e">			 */</span>
			module_put(ss<span style="color:#f92672">-&gt;</span>module);
<span style="color:#75715e">#ifdef CONFIG_MODULE_UNLOAD
</span><span style="color:#75715e"></span>			BUG_ON(ss<span style="color:#f92672">-&gt;</span>module <span style="color:#f92672">&amp;&amp;</span> <span style="color:#f92672">!</span>module_refcount(ss<span style="color:#f92672">-&gt;</span>module));
<span style="color:#75715e">#endif
</span><span style="color:#75715e"></span>		} <span style="color:#66d9ef">else</span> {
			<span style="color:#75715e">/* Subsystem state shouldn&#39;t exist */</span>
			BUG_ON(cgrp<span style="color:#f92672">-&gt;</span>subsys[i]);
		}
	}
	root<span style="color:#f92672">-&gt;</span>subsys_mask <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>actual_subsys_mask <span style="color:#f92672">=</span> final_subsys_mask;

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h4 id="创建对应的cgroup控制文件">创建对应的cgroup控制文件</h4>
<p><code>cgroup_populate_dir</code>用来创建对应的cgroup控制文件。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/**
</span><span style="color:#75715e"> * cgroup_populate_dir - selectively creation of files in a directory
</span><span style="color:#75715e"> * @cgrp: target cgroup
</span><span style="color:#75715e"> * @base_files: true if the base files should be added
</span><span style="color:#75715e"> * @subsys_mask: mask of the subsystem ids whose files should be added
</span><span style="color:#75715e"> */</span>
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cgroup_populate_dir</span>(<span style="color:#66d9ef">struct</span> cgroup <span style="color:#f92672">*</span>cgrp, <span style="color:#66d9ef">bool</span> base_files,
			       <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> subsys_mask)
{
	<span style="color:#66d9ef">int</span> err;
	<span style="color:#66d9ef">struct</span> cgroup_subsys <span style="color:#f92672">*</span>ss;

	<span style="color:#66d9ef">if</span> (base_files) { <span style="color:#75715e">// files 定义了cgroup的基本文件, true代表添加文件
</span><span style="color:#75715e"></span>		err <span style="color:#f92672">=</span> cgroup_addrm_files(cgrp, NULL, files, true);
		<span style="color:#66d9ef">if</span> (err <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span>)
			<span style="color:#66d9ef">return</span> err;
	}

	<span style="color:#75715e">/* process cftsets of each subsystem */</span>
	for_each_subsys(cgrp<span style="color:#f92672">-&gt;</span>root, ss) { <span style="color:#75715e">// 对于该层级上挂载的每一个cgroup子系统，创建控制文件
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">struct</span> cftype_set <span style="color:#f92672">*</span>set;
		<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>test_bit(ss<span style="color:#f92672">-&gt;</span>subsys_id, <span style="color:#f92672">&amp;</span>subsys_mask))
			<span style="color:#66d9ef">continue</span>;

		list_for_each_entry(set, <span style="color:#f92672">&amp;</span>ss<span style="color:#f92672">-&gt;</span>cftsets, node)
			cgroup_addrm_files(cgrp, ss, set<span style="color:#f92672">-&gt;</span>cfts, true);
	}

	<span style="color:#75715e">/* This cgroup is ready now */</span>
	for_each_subsys(cgrp<span style="color:#f92672">-&gt;</span>root, ss) {
		<span style="color:#66d9ef">struct</span> cgroup_subsys_state <span style="color:#f92672">*</span>css <span style="color:#f92672">=</span> cgrp<span style="color:#f92672">-&gt;</span>subsys[ss<span style="color:#f92672">-&gt;</span>subsys_id];
		<span style="color:#75715e">/*
</span><span style="color:#75715e">		 * Update id-&gt;css pointer and make this css visible from
</span><span style="color:#75715e">		 * CSS ID functions. This pointer will be dereferened
</span><span style="color:#75715e">		 * from RCU-read-side without locks.
</span><span style="color:#75715e">		 */</span>
		<span style="color:#66d9ef">if</span> (css<span style="color:#f92672">-&gt;</span>id)
			rcu_assign_pointer(css<span style="color:#f92672">-&gt;</span>id<span style="color:#f92672">-&gt;</span>css, css);
	}

	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p><code>err = cgroup_addrm_files(cgrp, NULL, files, true);</code>创建cgroup基本的控制文件，这些文件的信息定义在一个<code>files</code>的全局变量中。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#75715e">/*
</span><span style="color:#75715e"> * for the common functions, &#39;private&#39; gives the type of file
</span><span style="color:#75715e"> */</span>
<span style="color:#75715e">/* for hysterical raisins, we can&#39;t put this on the older files */</span>
<span style="color:#75715e">#define CGROUP_FILE_GENERIC_PREFIX &#34;cgroup.&#34;
</span><span style="color:#75715e"></span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">struct</span> cftype files[] <span style="color:#f92672">=</span> {
	{
		.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;tasks&#34;</span>,
		.open <span style="color:#f92672">=</span> cgroup_tasks_open,
		.write_u64 <span style="color:#f92672">=</span> cgroup_tasks_write,
		.release <span style="color:#f92672">=</span> cgroup_pidlist_release,
		.mode <span style="color:#f92672">=</span> S_IRUGO <span style="color:#f92672">|</span> S_IWUSR,
	},
	{
		.name <span style="color:#f92672">=</span> CGROUP_FILE_GENERIC_PREFIX <span style="color:#e6db74">&#34;procs&#34;</span>,
		.open <span style="color:#f92672">=</span> cgroup_procs_open,
		.write_u64 <span style="color:#f92672">=</span> cgroup_procs_write,
		.release <span style="color:#f92672">=</span> cgroup_pidlist_release,
		.mode <span style="color:#f92672">=</span> S_IRUGO <span style="color:#f92672">|</span> S_IWUSR,
	},
	{
		.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;notify_on_release&#34;</span>,
		.read_u64 <span style="color:#f92672">=</span> cgroup_read_notify_on_release,
		.write_u64 <span style="color:#f92672">=</span> cgroup_write_notify_on_release,
	},
	{
		.name <span style="color:#f92672">=</span> CGROUP_FILE_GENERIC_PREFIX <span style="color:#e6db74">&#34;event_control&#34;</span>,
		.write_string <span style="color:#f92672">=</span> cgroup_write_event_control,
		.mode <span style="color:#f92672">=</span> S_IWUGO,
	},
	{
		.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cgroup.clone_children&#34;</span>,
		.flags <span style="color:#f92672">=</span> CFTYPE_INSANE,
		.read_u64 <span style="color:#f92672">=</span> cgroup_clone_children_read,
		.write_u64 <span style="color:#f92672">=</span> cgroup_clone_children_write,
	},
	{
		.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;cgroup.sane_behavior&#34;</span>,
		.flags <span style="color:#f92672">=</span> CFTYPE_ONLY_ON_ROOT,
		.read_seq_string <span style="color:#f92672">=</span> cgroup_sane_behavior_show,
	},
	{
		.name <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;release_agent&#34;</span>,
		.flags <span style="color:#f92672">=</span> CFTYPE_ONLY_ON_ROOT,
		.read_seq_string <span style="color:#f92672">=</span> cgroup_release_agent_show,
		.write_string <span style="color:#f92672">=</span> cgroup_release_agent_write,
		.max_write_len <span style="color:#f92672">=</span> PATH_MAX,
	},
	{ }	<span style="color:#75715e">/* terminate */</span>
};
</code></pre></div><h3 id="remount的一些限制">remount的一些限制</h3>
<p><code>cgroup_remount</code>执行对cgroup挂载点remount的操作：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">cgroup_remount</span>(<span style="color:#66d9ef">struct</span> super_block <span style="color:#f92672">*</span>sb, <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>flags, <span style="color:#66d9ef">char</span> <span style="color:#f92672">*</span>data)
{
	<span style="color:#66d9ef">int</span> ret <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> sb<span style="color:#f92672">-&gt;</span>s_fs_info;
	<span style="color:#66d9ef">struct</span> cgroup <span style="color:#f92672">*</span>cgrp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>top_cgroup;
	<span style="color:#66d9ef">struct</span> cgroup_sb_opts opts;
	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> added_mask, removed_mask;
	<span style="color:#75715e">// __DEVEL__sane_behavior 指定后，不允许进行remount操作
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> CGRP_ROOT_SANE_BEHAVIOR) {
		pr_err(<span style="color:#e6db74">&#34;cgroup: sane_behavior: remount is not allowed</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span>EINVAL;
	}

	mutex_lock(<span style="color:#f92672">&amp;</span>cgrp<span style="color:#f92672">-&gt;</span>dentry<span style="color:#f92672">-&gt;</span>d_inode<span style="color:#f92672">-&gt;</span>i_mutex);
	mutex_lock(<span style="color:#f92672">&amp;</span>cgroup_mutex);
	mutex_lock(<span style="color:#f92672">&amp;</span>cgroup_root_mutex);

	<span style="color:#75715e">/* See what subsystems are wanted */</span> <span style="color:#75715e">// 解析remount的选项
</span><span style="color:#75715e"></span>	ret <span style="color:#f92672">=</span> parse_cgroupfs_options(data, <span style="color:#f92672">&amp;</span>opts);
	<span style="color:#66d9ef">if</span> (ret)
		<span style="color:#66d9ef">goto</span> out_unlock;
	<span style="color:#75715e">// 不建议remount时修改层级的子系统或者其他选项，该功能已经废弃
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (opts.subsys_mask <span style="color:#f92672">!=</span> root<span style="color:#f92672">-&gt;</span>actual_subsys_mask <span style="color:#f92672">||</span> opts.release_agent)
		pr_warning(<span style="color:#e6db74">&#34;cgroup: option changes via remount are deprecated (pid=%d comm=%s)</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>,
			   task_tgid_nr(current), current<span style="color:#f92672">-&gt;</span>comm);

	added_mask <span style="color:#f92672">=</span> opts.subsys_mask <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>root<span style="color:#f92672">-&gt;</span>subsys_mask;
	removed_mask <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>subsys_mask <span style="color:#f92672">&amp;</span> <span style="color:#f92672">~</span>opts.subsys_mask;

	<span style="color:#75715e">// flags和name在remount时不允许改变
</span><span style="color:#75715e"></span>	<span style="color:#75715e">/* Don&#39;t allow flags or name to change at remount */</span>
	<span style="color:#66d9ef">if</span> (opts.flags <span style="color:#f92672">!=</span> root<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">||</span>
	    (opts.name <span style="color:#f92672">&amp;&amp;</span> strcmp(opts.name, root<span style="color:#f92672">-&gt;</span>name))) {
		ret <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>EINVAL;
		drop_parsed_module_refcounts(opts.subsys_mask);
		<span style="color:#66d9ef">goto</span> out_unlock;
	}

	<span style="color:#75715e">/*
</span><span style="color:#75715e">	 * Clear out the files of subsystems that should be removed, do
</span><span style="color:#75715e">	 * this before rebind_subsystems, since rebind_subsystems may
</span><span style="color:#75715e">	 * change this hierarchy&#39;s subsys_list.
</span><span style="color:#75715e">	 */</span><span style="color:#75715e">//删除 要删除的cgroup子系统的控制文件
</span><span style="color:#75715e"></span>	cgroup_clear_directory(cgrp<span style="color:#f92672">-&gt;</span>dentry, false, removed_mask);

	ret <span style="color:#f92672">=</span> rebind_subsystems(root, opts.subsys_mask);
	<span style="color:#66d9ef">if</span> (ret) {
		<span style="color:#75715e">/* rebind_subsystems failed, re-populate the removed files */</span>
		cgroup_populate_dir(cgrp, false, removed_mask);
		drop_parsed_module_refcounts(opts.subsys_mask);
		<span style="color:#66d9ef">goto</span> out_unlock;
	}

	<span style="color:#75715e">/* re-populate subsystem files */</span>
	<span style="color:#75715e">// 添加 要添加的cgroup子系统的控制文件
</span><span style="color:#75715e"></span>	cgroup_populate_dir(cgrp, false, added_mask);

	<span style="color:#66d9ef">if</span> (opts.release_agent)
		strcpy(root<span style="color:#f92672">-&gt;</span>release_agent_path, opts.release_agent);
 out_unlock:
	kfree(opts.release_agent);
	kfree(opts.name);
	mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_root_mutex);
	mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_mutex);
	mutex_unlock(<span style="color:#f92672">&amp;</span>cgrp<span style="color:#f92672">-&gt;</span>dentry<span style="color:#f92672">-&gt;</span>d_inode<span style="color:#f92672">-&gt;</span>i_mutex);
	<span style="color:#66d9ef">return</span> ret;
}

</code></pre></div><h3 id="umount">umount</h3>
<p><code>cgroup_kill_sb</code>是执行umount <code>cgroup</code>文件系统的内核方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c" data-lang="c"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">cgroup_kill_sb</span>(<span style="color:#66d9ef">struct</span> super_block <span style="color:#f92672">*</span>sb) {
	<span style="color:#66d9ef">struct</span> cgroupfs_root <span style="color:#f92672">*</span>root <span style="color:#f92672">=</span> sb<span style="color:#f92672">-&gt;</span>s_fs_info;
	<span style="color:#66d9ef">struct</span> cgroup <span style="color:#f92672">*</span>cgrp <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>top_cgroup;
	<span style="color:#66d9ef">int</span> ret;
	<span style="color:#66d9ef">struct</span> cg_cgroup_link <span style="color:#f92672">*</span>link;
	<span style="color:#66d9ef">struct</span> cg_cgroup_link <span style="color:#f92672">*</span>saved_link;

	BUG_ON(<span style="color:#f92672">!</span>root);
	<span style="color:#75715e">// umount时，该层级上的cgroup个数必须为1
</span><span style="color:#75715e"></span>	BUG_ON(root<span style="color:#f92672">-&gt;</span>number_of_cgroups <span style="color:#f92672">!=</span> <span style="color:#ae81ff">1</span>);
	<span style="color:#75715e">// umount时，该层级的root cgroup必须没有子cgroup
</span><span style="color:#75715e"></span>	BUG_ON(<span style="color:#f92672">!</span>list_empty(<span style="color:#f92672">&amp;</span>cgrp<span style="color:#f92672">-&gt;</span>children));

	mutex_lock(<span style="color:#f92672">&amp;</span>cgroup_mutex);
	mutex_lock(<span style="color:#f92672">&amp;</span>cgroup_root_mutex);

	<span style="color:#75715e">/* Rebind all subsystems back to the default hierarchy */</span>
	<span style="color:#75715e">// 删除该层级上所有附加的cgroup子系统
</span><span style="color:#75715e"></span>	ret <span style="color:#f92672">=</span> rebind_subsystems(root, <span style="color:#ae81ff">0</span>);
	<span style="color:#75715e">/* Shouldn&#39;t be able to fail ... */</span>
	BUG_ON(ret);

	<span style="color:#75715e">/*
</span><span style="color:#75715e">	 * Release all the links from css_sets to this hierarchy&#39;s
</span><span style="color:#75715e">	 * root cgroup
</span><span style="color:#75715e">	 */</span>
	write_lock(<span style="color:#f92672">&amp;</span>css_set_lock);

	list_for_each_entry_safe(link, saved_link, <span style="color:#f92672">&amp;</span>cgrp<span style="color:#f92672">-&gt;</span>css_sets,
				 cgrp_link_list) {
		list_del(<span style="color:#f92672">&amp;</span>link<span style="color:#f92672">-&gt;</span>cg_link_list);
		list_del(<span style="color:#f92672">&amp;</span>link<span style="color:#f92672">-&gt;</span>cgrp_link_list);
		kfree(link);
	}
	write_unlock(<span style="color:#f92672">&amp;</span>css_set_lock);
	<span style="color:#75715e">// 在roots链表中删除该cgroupfs_root
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>list_empty(<span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>root_list)) {
		list_del(<span style="color:#f92672">&amp;</span>root<span style="color:#f92672">-&gt;</span>root_list);
		root_count<span style="color:#f92672">--</span>;
	}

	mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_root_mutex);
	mutex_unlock(<span style="color:#f92672">&amp;</span>cgroup_mutex);

	simple_xattrs_free(<span style="color:#f92672">&amp;</span>cgrp<span style="color:#f92672">-&gt;</span>xattrs);

	kill_litter_super(sb);
	cgroup_drop_root(root);
}
</code></pre></div><h3 id="参考文章">参考文章</h3>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">laoqinren</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-08-25</span>
  </p>
  <p class="copyright-item">
      <span class="item-title">Markdown</span>
      <span class="item-content"><a class="link-to-markdown" href="http://linux.laoqinren.net/kernel/cgroup-source-cgroup_mount/index.md" target="_blank">The Markdown version »</a></span>
    </p>
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/kernel/">kernel</a>
          
          <a href="/tags/linux/">linux</a>
          
          <a href="/tags/cgroup/">cgroup</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/kernel/cgroup-source-css-set-hash/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">cgroup源码分析4——css_set的哈希表分析</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/kernel/cgroup-source-cgroup_init/">
            <span class="next-text nav-default">cgroup源码分析2——cgroup的初始化</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'laoqinren';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:w@laoqinren.net" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/0x0916" class="iconfont icon-github" title="github"></a>
  <a href="http://linux.laoqinren.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">laoqinren</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>








</body>
</html>
