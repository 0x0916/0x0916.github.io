<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>获取容器中init进程的pid - Notes about linux and my work</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="laoqinren" />
  <meta name="description" content="本文题目为『获取容器中init进程的pid』，其实说的还不够详细。其实容器中的进程都单独运行在一个独立的pid namespace中，而我们有时需要在顶级的pid namespace中获取其init进程对应的在顶级pid namespace的pid。
本文简要介绍了完成这个任务的一种方法。
" />

  <meta name="keywords" content="Linux, kernel" />






<meta name="generator" content="Hugo 0.59.1" />


<link rel="canonical" href="http://linux.laoqinren.net/linux/get-init-pid-for-any-task/" />

<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">







<link href="/dist/even.min.css?v=3.1.1" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">




<meta property="og:title" content="获取容器中init进程的pid" />
<meta property="og:description" content="本文题目为『获取容器中init进程的pid』，其实说的还不够详细。其实容器中的进程都单独运行在一个独立的pid namespace中，而我们有时需要在顶级的pid namespace中获取其init进程对应的在顶级pid namespace的pid。

本文简要介绍了完成这个任务的一种方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://linux.laoqinren.net/linux/get-init-pid-for-any-task/" />
<meta property="article:published_time" content="2018-10-08T14:26:43+08:00" />
<meta property="article:modified_time" content="2018-10-08T14:26:43+08:00" />
<meta itemprop="name" content="获取容器中init进程的pid">
<meta itemprop="description" content="本文题目为『获取容器中init进程的pid』，其实说的还不够详细。其实容器中的进程都单独运行在一个独立的pid namespace中，而我们有时需要在顶级的pid namespace中获取其init进程对应的在顶级pid namespace的pid。

本文简要介绍了完成这个任务的一种方法。">


<meta itemprop="datePublished" content="2018-10-08T14:26:43&#43;08:00" />
<meta itemprop="dateModified" content="2018-10-08T14:26:43&#43;08:00" />
<meta itemprop="wordCount" content="1467">



<meta itemprop="keywords" content="kernel,linux," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="获取容器中init进程的pid"/>
<meta name="twitter:description" content="本文题目为『获取容器中init进程的pid』，其实说的还不够详细。其实容器中的进程都单独运行在一个独立的pid namespace中，而我们有时需要在顶级的pid namespace中获取其init进程对应的在顶级pid namespace的pid。

本文简要介绍了完成这个任务的一种方法。"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Notes</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/linux/">
        <li class="mobile-menu-item">linux</li>
      </a><a href="/kernel/">
        <li class="mobile-menu-item">Kernel</li>
      </a><a href="/posts/">
        <li class="mobile-menu-item">Blog</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/archives/">
        <li class="mobile-menu-item">Archives</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Notes</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/linux/">linux</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/kernel/">Kernel</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/posts/">Blog</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/archives/">Archives</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">获取容器中init进程的pid</h1>

      <div class="post-meta">
        <span class="post-time"> 2018-10-08 </span>
        <div class="post-category">
            
              <a href="/categories/linux/"> linux </a>
            
          </div>
        <span class="more-meta"> 1467 words </span>
        <span class="more-meta"> 3 mins read </span>
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  
  <div class="post-toc-content">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li>
<ul>
<li><a href="#实现方法">实现方法</a></li>
<li><a href="#代码实现">代码实现</a></li>
<li><a href="#编译运行">编译运行</a></li>
<li><a href="#参考文章">参考文章</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <p>本文题目为『<strong>获取容器中init进程的pid</strong>』，其实说的还不够详细。其实容器中的进程都单独运行在一个独立的<code>pid namespace</code>中，而我们有时需要在顶级的<code>pid namespace</code>中获取其<code>init</code>进程对应的在顶级<code>pid namespace</code>的<code>pid</code>。</p>

<p>本文简要介绍了完成这个任务的一种方法。</p>

<h3 id="实现方法">实现方法</h3>

<p>我们注意到<a href="http://man7.org/linux/man-pages/man7/pid_namespaces.7.html">man 7 pid_namespaces</a>有如下一段描述：</p>

<pre><code>   Miscellaneous
       When a process ID is passed over a UNIX domain socket to a process in
       a different PID namespace (see the description of SCM_CREDENTIALS in
       unix(7)), it is translated into the corresponding PID value in the
       receiving process's PID namespace.
</code></pre>

<p>什么意思呢？简单翻译一下：</p>

<p>当通过<code>Unix domain socket</code>进行发送<code>UNIX credentials</code>到不同的<code>pid namespace</code>中的进程时，对应的pid号会被转换成再接受进程所在的<code>pid namespace</code>中的进程号。</p>

<p>所以，我们可以使用如下办法完成任务：</p>

<ul>
<li>新建一个进程A，建立一个<code>unix domain socket</code></li>
<li>fork 进程B，将B添加到目标<code>pid namespace</code>中</li>
<li>B 通过<code>unix domain socket</code>发送<code>UNIX credentials</code>到A，发送的pid设置为1</li>
<li>A解析出收到的pid号就是我们想要的</li>
</ul>

<h3 id="代码实现">代码实现</h3>

<pre><code class="language-c">#define _GNU_SOURCE

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;sys/epoll.h&gt;
#include &lt;wait.h&gt;

#define SEND_CREDS_OK 0
#define SEND_CREDS_NOTSK 1
#define SEND_CREDS_FAIL 2
static bool recv_creds(int sock, struct ucred *cred, char *v);
static int wait_for_pid(pid_t pid);
static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst);
static int send_creds_clone_wrapper(void *arg);


static int send_creds_clone_wrapper(void *arg)
{
	struct ucred cred;
	char v;
	int sock = *(int*)arg;

	cred.uid = 0;
	cred.gid = 0;
	cred.pid = 1;

	v = '1';
	if (send_creds(sock, &amp;cred, v, true) != SEND_CREDS_OK)
		return 1;
	return 0;
}

static int wait_for_pid(pid_t pid)
{
	int status, ret;

	if (pid &lt; 0)
		return -1;

again:
	ret = waitpid(pid, &amp;status, 0);
	if (ret == -1) {
		if (errno = EINTR)
			goto again;
		return -1;
	}

	if (ret != pid)
		goto again;

	if (!WIFEXITED(status) || WEXITSTATUS(status) != 0)
		return -1;

	return 0;
}

/*
 * clone a task which switches to @task's namespace and writes '1'.
 * over a unix sock so we can read the task's reaper's pid in our
 * namespace
 *
 * Note: glibc's fork() does not respect pidns, which can lead to failed
 * assertions inside glibc (and thus failed forks) if the child's pid in
 * the pidns and the parent pid outside are identical. Using clone prevents
 * this issue.
 */
static void write_task_init_pid_exit(int sock, pid_t target)
{
	char fnam[100];
	pid_t pid;
	int fd, ret;
	size_t stack_size = sysconf(_SC_PAGESIZE);
	void *stack = alloca(stack_size);

	ret = snprintf(fnam, sizeof(fnam), &quot;/proc/%d/ns/pid&quot;, (int)target);
	if (ret &lt; 0 || ret &gt;= sizeof(fnam))
		_exit(1);

	fd = open(fnam, O_RDONLY);
	if (fd &lt; 0) {
		perror(&quot;write_task_init_pid_exit open of ns/pid&quot; );
		_exit(1);
	}

	if (setns(fd, 0)) {
		perror(&quot;write_task_init_pid_exit setns 1&quot;);
		close(fd);
		_exit(1);
	}

	pid = clone(send_creds_clone_wrapper, stack+stack_size, SIGCHLD, &amp;sock);
	if (pid &lt; 0)
		_exit(1);

	if (pid != 0) {
		if (!wait_for_pid(pid))
			_exit(1);
		_exit(0);
	}
}

static pid_t get_init_pid_for_task(pid_t task)
{
	int sock[2];
	pid_t pid;
	pid_t ret = -1;
	char v = '0';
	struct ucred cred;

	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, sock) &lt; 0 ) {
		perror(&quot;socketpair&quot;);
		return -1;
	}

	pid = fork();

	if (pid &lt; 0)
		goto out;

	if (!pid) {
		// Child process
		close(sock[1]);
		write_task_init_pid_exit(sock[0], task);
		_exit(0);
	}

	if (!recv_creds(sock[1], &amp;cred, &amp;v))
		goto out;

	ret = cred.pid;

out:
	close(sock[0]);
	close(sock[1]);

	if (pid &gt; 0)
		wait_for_pid(pid);

	return ret;
}

void usage(int argc, char **argv)
{
	printf(&quot;Usage:\n&quot;);
	printf(&quot;\t%s pid\n&quot;, argv[1]);
}

int main(int argc, char **argv)
{
	pid_t result;
	pid_t target;

	if (argc != 2) {
		usage(argc, argv);
		exit(0);
	}

	target = (pid_t)atoi(argv[1]);
	result = get_init_pid_for_task(target);

	printf(&quot;pid %d 's init pid is %d\n&quot;, (int)target, (int)result);
}



#define POLLIN_SET ( EPOLLIN | EPOLLHUP | EPOLLRDHUP )

static bool wait_for_sock(int sock, int timeout)
{
	struct epoll_event ev;
	int epfd, ret, now, starttime, deltatime, saved_errno;

	if ((starttime = time(NULL)) &lt; 0)
		return false;

	if ((epfd = epoll_create(1)) &lt; 0) {
		printf(&quot;%s\n&quot;, &quot;Failed to create epoll socket: %m.&quot;);
		return false;
	}

	ev.events = POLLIN_SET;
	ev.data.fd = sock;
	if (epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &amp;ev) &lt; 0) {
		printf(&quot;%s\n&quot;, &quot;Failed adding socket to epoll: %m.&quot;);
		close(epfd);
		return false;
	}

again:
	if ((now = time(NULL)) &lt; 0) {
		close(epfd);
		return false;
	}

	deltatime = (starttime + timeout) - now;
	if (deltatime &lt; 0) { // timeout
		errno = 0;
		close(epfd);
		return false;
	}
	ret = epoll_wait(epfd, &amp;ev, 1, 1000*deltatime + 1);
	if (ret &lt; 0 &amp;&amp; errno == EINTR)
		goto again;
	saved_errno = errno;
	close(epfd);

	if (ret &lt;= 0) {
		errno = saved_errno;
		return false;
	}
	return true;
}

static int msgrecv(int sockfd, void *buf, size_t len)
{
	if (!wait_for_sock(sockfd, 2))
		return -1;
	return recv(sockfd, buf, len, MSG_DONTWAIT);
}

static int send_creds(int sock, struct ucred *cred, char v, bool pingfirst)
{
	struct msghdr msg = { 0 };
	struct iovec iov;
	struct cmsghdr *cmsg;
	char cmsgbuf[CMSG_SPACE(sizeof(*cred))];
	char buf[1];
	buf[0] = 'p';

	if (pingfirst) {
		if (msgrecv(sock, buf, 1) != 1) {
			printf(&quot;%s\n&quot;, &quot;Error getting reply from server over socketpair.&quot;);
			return SEND_CREDS_FAIL;
		}
	}

	msg.msg_control = cmsgbuf;
	msg.msg_controllen = sizeof(cmsgbuf);

	cmsg = CMSG_FIRSTHDR(&amp;msg);
	cmsg-&gt;cmsg_len = CMSG_LEN(sizeof(struct ucred));
	cmsg-&gt;cmsg_level = SOL_SOCKET;
	cmsg-&gt;cmsg_type = SCM_CREDENTIALS;
	memcpy(CMSG_DATA(cmsg), cred, sizeof(*cred));

	msg.msg_name = NULL;
	msg.msg_namelen = 0;

	buf[0] = v;
	iov.iov_base = buf;
	iov.iov_len = sizeof(buf);
	msg.msg_iov = &amp;iov;
	msg.msg_iovlen = 1;

	if (sendmsg(sock, &amp;msg, 0) &lt; 0) {
		printf(&quot;Failed at sendmsg: %s.\n&quot;,strerror(errno));
		if (errno == 3)
			return SEND_CREDS_NOTSK;
		return SEND_CREDS_FAIL;
	}

	return SEND_CREDS_OK;
}

static bool recv_creds(int sock, struct ucred *cred, char *v)
{
	struct msghdr msg = { 0 };
	struct iovec iov;
	struct cmsghdr *cmsg;
	char cmsgbuf[CMSG_SPACE(sizeof(*cred))];
	char buf[1];
	int ret;
	int optval = 1;

	*v = '1';

	cred-&gt;pid = -1;
	cred-&gt;uid = -1;
	cred-&gt;gid = -1;

	if (setsockopt(sock, SOL_SOCKET, SO_PASSCRED, &amp;optval, sizeof(optval)) == -1) {
		printf(&quot;Failed to set passcred: %s\n&quot;, strerror(errno));
		return false;
	}
	buf[0] = '1';
	if (write(sock, buf, 1) != 1) {
		printf(&quot;Failed to start write on scm fd: %s\n&quot;, strerror(errno));
		return false;
	}

	msg.msg_name = NULL;
	msg.msg_namelen = 0;
	msg.msg_control = cmsgbuf;
	msg.msg_controllen = sizeof(cmsgbuf);

	iov.iov_base = buf;
	iov.iov_len = sizeof(buf);
	msg.msg_iov = &amp;iov;
	msg.msg_iovlen = 1;

	if (!wait_for_sock(sock, 2)) {
		printf(&quot;Timed out waiting for scm_cred: %s\n&quot;, strerror(errno));
		return false;
	}
	ret = recvmsg(sock, &amp;msg, MSG_DONTWAIT);
	if (ret &lt; 0) {
		printf(&quot;Failed to receive scm_cred: %s\n&quot;, strerror(errno));
		return false;
	}

	cmsg = CMSG_FIRSTHDR(&amp;msg);

	if (cmsg &amp;&amp; cmsg-&gt;cmsg_len == CMSG_LEN(sizeof(struct ucred)) &amp;&amp;
			cmsg-&gt;cmsg_level == SOL_SOCKET &amp;&amp;
			cmsg-&gt;cmsg_type == SCM_CREDENTIALS) {
		memcpy(cred, CMSG_DATA(cmsg), sizeof(*cred));
	}
	*v = buf[0];

	return true;
}
</code></pre>

<h3 id="编译运行">编译运行</h3>

<pre><code class="language-bash"># # 将源码保存为main.c
# gcc -o get_init_pid  main.c 
# docker top 9ce36bf4bb30
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                3244                3228                0                   14:22               pts/1               00:00:00            /bin/bash
root                3312                3286                0                   14:22               ?                   00:00:00            sleep 3400
root                3313                3286                0                   14:22               ?                   00:00:00            sleep 3400
root                3314                3286                0                   14:22               ?                   00:00:00            sleep 3400
root                3315                3286                0                   14:22               ?                   00:00:00            sleep 3400
# ./get_init_pid 3312
pid 3312 's init pid is 3244
# ./get_init_pid 3315
pid 3315 's init pid is 3244
# ./get_init_pid 3244
pid 3244 's init pid is 3244
# ./get_init_pid 1
pid 1 's init pid is 1
# ./get_init_pid 2
pid 2 's init pid is 1
</code></pre>

<h3 id="参考文章">参考文章</h3>

<ul>
<li><a href="http://man7.org/linux/man-pages/man7/unix.7.html">http://man7.org/linux/man-pages/man7/unix.7.html</a></li>
<li><a href="http://man7.org/linux/man-pages/man7/pid_namespaces.7.html">http://man7.org/linux/man-pages/man7/pid_namespaces.7.html</a></li>
</ul>
    </div>

    
    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">laoqinren</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">2018-10-08</span>
  </p>
  <p class="copyright-item">
      <span class="item-title">Markdown</span>
      <span class="item-content"><a class="link-to-markdown" href="http://linux.laoqinren.net/linux/get-init-pid-for-any-task/index.md" target="_blank">The Markdown version »</a></span>
    </p>
  
</div>

    
    

    <footer class="post-footer">
      <div class="post-tags">
          
          <a href="/tags/kernel/">kernel</a>
          
          <a href="/tags/linux/">linux</a>
          
        </div>

      
      <nav class="post-nav">
        
          <a class="prev" href="/linux/proc-memory/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">内核中内存信息的展示</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        
          <a class="next" href="/linux/passing-file-descriptors/">
            <span class="next-text nav-default">传递文件描述符</span>
            <span class="prev-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        
  <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'laoqinren';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:w@laoqinren.net" class="iconfont icon-email" title="email"></a>
      <a href="http://github.com/0x0916" class="iconfont icon-github" title="github"></a>
  <a href="http://linux.laoqinren.net/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    
      2016 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">laoqinren</span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
<script src="/lib/highlight/highlight.pack.js?v=20171001"></script><script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>
<script type="text/javascript" src="/dist/even.min.js?v=3.1.1"></script>








</body>
</html>
